<!DOCTYPE html>
<html lang="zh-CN">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>åœ°å›¾æ ¼å­ç”Ÿæˆå·¥å…·</title>
        <style>
            :root {
                --old-control-width: 320px;
                --new-control-width: calc(var(--old-control-width) * 0.8);
                /* 80% of previous */
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: 'Arial', sans-serif;
                background-color: #f0f0f0;
                display: flex;
                justify-content: center;
                align-items: flex-start;
                min-height: 100vh;
                padding: 20px;
            }

            /* å››åˆ—å¸ƒå±€ï¼šå·¦ã€ä¸­å·¦ã€ä¸­å³ã€å³ */
            .container {
                display: grid;
                grid-template-columns: var(--new-control-width) var(--new-control-width) 1fr var(--new-control-width);
                gap: 20px;
                max-width: 1600px;
                width: 100%;
                align-items: start;
            }

            .controls {
                background: white;
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
                width: 100%;
                max-width: 100%;
            }

            .layer-panel {
                /* ç¬¬äºŒåˆ—å®¹å™¨ */
                background: white;
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
                width: 100%;
                max-width: 100%;
            }

            .alliance-panel {
                /* ç¬¬å››åˆ—å®¹å™¨ */
                background: white;
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
                width: 100%;
                max-width: 100%;
            }

            .controls h1,
            .layer-panel h1 {
                font-size: 20px;
                margin-bottom: 12px;
                color: #333;
                text-align: center;
            }

            .input-group {
                margin-bottom: 15px;
            }

            .input-group label {
                display: block;
                margin-bottom: 5px;
                font-weight: bold;
                color: #555;
            }

            .input-group input {
                width: 100%;
                padding: 8px;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 14px;
                /* éšè—ä¸Šä¸‹å¢å‡æŒ‰é’® */
                -moz-appearance: textfield;
                -webkit-appearance: textfield;
                appearance: textfield;
            }

            /* é’ˆå¯¹Chromeã€Safariã€Edgeã€Opera */
            .input-group input::-webkit-outer-spin-button,
            .input-group input::-webkit-inner-spin-button {
                -webkit-appearance: none;
                margin: 0;
            }

            /* é’ˆå¯¹Firefox */
            .input-group input::-moz-number-spin-box {
                display: none;
            }

            /* é€šç”¨è§„åˆ™ - å¤„ç†æ‰€æœ‰numberç±»å‹çš„input */
            input[type="number"] {
                /* éšè—ä¸Šä¸‹å¢å‡æŒ‰é’® */
                -moz-appearance: textfield;
                -webkit-appearance: textfield;
                appearance: textfield;
            }

            /* é’ˆå¯¹Chromeã€Safariã€Edgeã€Opera */
            input[type="number"]::-webkit-outer-spin-button,
            input[type="number"]::-webkit-inner-spin-button {
                -webkit-appearance: none;
                margin: 0;
            }

            /* é’ˆå¯¹Firefox */
            input[type="number"]::-moz-number-spin-box {
                display: none;
            }

            .input-hint {
                display: block;
                margin-top: 3px;
                font-size: 11px;
                color: #888;
            }

            .button-group {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
                margin-bottom: 20px;
            }

            button {
                padding: 10px 15px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: background-color 0.3s;
            }

            #generateBtn {
                background-color: #007bff;
                color: white;
                grid-column: span 2;
            }

            #generateBtn:hover {
                background-color: #0056b3;
            }


            #printBtn {
                background-color: #dc3545;
                color: white;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            #printBtn:hover {
                background-color: #c82333;
            }

            .info-panel {
                background-color: #f8f9fa;
                padding: 15px;
                border-radius: 4px;
                border: 1px solid #e9ecef;
                margin-bottom: 12px;
            }

            .info-panel h3 {
                margin-bottom: 10px;
                color: #333;
            }

            #cellInfo {
                font-size: 14px;
                color: #666;
                line-height: 1.5;
            }

            .preset-btn {
                padding: 5px 8px;
                font-size: 12px;
                background-color: #f8f9fa;
                border: 1px solid #dee2e6;
                color: #495057;
                border-radius: 3px;
                cursor: pointer;
                transition: all 0.2s;
            }

            .preset-btn:hover {
                background-color: #e9ecef;
                border-color: #adb5bd;
            }

            .preset-btn.active {
                background-color: #007bff;
                color: white;
                border-color: #007bff;
            }

            .layer-controls {
                background-color: transparent;
                padding: 0;
                border-radius: 4px;
            }

            .layer-controls label {
                display: block;
                font-weight: bold;
                margin-bottom: 6px;
                color: #333;
                font-size: 13px;
            }

            #layerSelect {
                width: 100%;
                height: 120px;
                padding: 6px;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 13px;
                margin-bottom: 8px;
                box-sizing: border-box;
            }

            #monsterSelect,
            #resourceSelect {
                width: 100%;
                height: 130px;
                padding: 6px;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 13px;
                margin-bottom: 6px;
                box-sizing: border-box;
            }

            #highlightBtn {
                background-color: #20c997;
                color: white;
                margin-right: 8px;
            }

            #clearHighlightBtn {
                background-color: #6c757d;
                color: white;
            }

            #applyMonsterBtn {
                background-color: #e67e22;
                color: white;
                margin-top: 6px;
            }

            #applyMonsterToCellBtn {
                background-color: #8B814C;
                color: white;
                margin-top: 6px;
            }

            #applyResourceBtn {
                background-color: #17a2b8;
                color: white;
                margin-top: 6px;
            }

            #applyResourceToCellBtn {
                background-color: #8B814C;
                color: white;
                margin-top: 6px;
            }

            #exportResourceBtn {
                background-color: #6f42c1;
                color: white;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .canvas-container {
                background: white;
                border-radius: 10px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
                padding: 20px;
                display: flex;
                flex-direction: column;
                justify-content: flex-start;
                align-items: center;
                overflow: hidden;
                min-width: 0;
                min-height: 700px;
            }

            #mapCanvas {
                border: 1px solid #ccc;
                cursor: crosshair;
                display: block;
                max-width: 100%;
                height: auto;
            }

            /* responsive: single column on narrow screens */
            @media (max-width: 1400px) {
                .container {
                    grid-template-columns: var(--new-control-width) 1fr;
                }

                .alliance-panel {
                    grid-column: span 2;
                }
            }

            @media (max-width: 900px) {
                .container {
                    grid-template-columns: 1fr;
                }

                #layerSelect {
                    height: 140px;
                }

                .canvas-container {
                    min-height: 360px;
                }
            }

            @media (max-width: 480px) {
                .button-group {
                    grid-template-columns: 1fr;
                }

                #generateBtn,
                #printBtn {
                    grid-column: span 1;
                }
            }

            /* åŠ è½½åŠ¨ç”»CSS */
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }

            @keyframes fadeIn {
                from { opacity: 0; transform: scale(0.9); }
                to { opacity: 1; transform: scale(1); }
            }

            @keyframes pulse {
                0% { transform: scale(1); }
                50% { transform: scale(1.05); }
                100% { transform: scale(1); }
            }

            /* é€šçŸ¥åŠ¨ç”»æ ·å¼ */
            @keyframes slideInRight {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }

            @keyframes slideOutRight {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(100%);
                    opacity: 0;
                }
            }

            @keyframes resourcePulse {
                0% {
                    transform: scale(1);
                    box-shadow: 0 0 0 rgba(0, 123, 255, 0.7);
                }
                50% {
                    transform: scale(1.1);
                    box-shadow: 0 0 20px rgba(0, 123, 255, 0.7);
                }
                100% {
                    transform: scale(1);
                    box-shadow: 0 0 0 rgba(0, 123, 255, 0.7);
                }
            }

            .notification {
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                z-index: 10000;
                max-width: 400px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                animation: slideInRight 0.3s ease-out;
            }

            .notification.success {
                background: linear-gradient(135deg, #28a745, #20c997);
            }

            .notification.info {
                background: linear-gradient(135deg, #007bff, #6610f2);
            }

            .notification.warning {
                background: linear-gradient(135deg, #ffc107, #fd7e14);
            }

            .notification.error {
                background: linear-gradient(135deg, #dc3545, #e83e8c);
            }

            .notification.hiding {
                animation: slideOutRight 0.3s ease-in forwards;
            }

            /* ========== ä¸»é¢˜æ ·å¼ ========== */

            /* æ·±è‰²ä¸»é¢˜ */
            body.dark-theme {
                background-color: #1a1a1a;
                color: #e9ecef;
            }

            body.dark-theme .container {
                background-color: #2d3748;
                color: #e9ecef;
            }

            body.dark-theme .controls,
            body.dark-theme .layer-panel,
            body.dark-theme .alliance-panel,
            body.dark-theme .canvas-container {
                background-color: #374151;
                color: #e9ecef;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            }

            body.dark-theme input,
            body.dark-theme select,
            body.dark-theme textarea {
                background-color: #4b5563;
                color: #e9ecef;
                border-color: #6b7280;
            }

            body.dark-theme button {
                background-color: #4b5563;
                color: #e9ecef;
                border-color: #6b7280;
            }

            body.dark-theme button:hover {
                background-color: #6b7280;
            }

            body.dark-theme .input-hint {
                color: #9ca3af;
            }

            /* æ·±è‰²ä¸»é¢˜ä¸‹çš„æ ‡é¢˜å’Œæ ‡ç­¾æ–‡å­— */
            body.dark-theme h1,
            body.dark-theme h2,
            body.dark-theme h3,
            body.dark-theme h4,
            body.dark-theme h5,
            body.dark-theme h6 {
                color: #e9ecef;
            }

            body.dark-theme label {
                color: #e9ecef;
            }

            body.dark-theme .input-hint {
                color: #9ca3af;
            }

            body.dark-theme small {
                color: #9ca3af;
            }

            /* æ·±è‰²ä¸»é¢˜ä¸‹çš„é“¾æ¥å’ŒæŒ‰é’®æ–‡å­— */
            body.dark-theme a {
                color: #60a5fa;
            }

            body.dark-theme .info-panel {
                background-color: #374151;
                color: #e9ecef;
                border-color: #4b5563;
            }

            body.dark-theme #cellInfo {
                color: #e9ecef;
            }

            /* æ·±è‰²ä¸»é¢˜ä¸‹çš„å…¶ä»–ç™½è‰²èƒŒæ™¯ */
            body.dark-theme .theme-controls div[style*="background: #f8f9fa"] {
                background-color: #374151 !important;
            }

            body.dark-theme div[style*="background: #f8f9fa"] {
                background-color: #374151 !important;
            }

            body.dark-theme div[style*="background: #fff"] {
                background-color: #374151 !important;
                color: #e9ecef;
            }

            body.dark-theme div[style*="background: #fff3cd"] {
                background-color: #4b5563 !important;
                color: #e9ecef;
            }

            body.dark-theme #densityMapContainer {
                background-color: #374151 !important;
                color: #e9ecef;
                border-color: #4b5563;
            }

            body.dark-theme #chartContainer {
                background-color: #374151 !important;
                color: #e9ecef;
                border-color: #4b5563;
            }

            body.dark-theme #resourceCoordsList {
                background-color: #374151 !important;
                color: #e9ecef;
            }

            body.dark-theme .preset-btn {
                background-color: #4b5563 !important;
                color: #e9ecef;
                border-color: #6b7280;
            }

            body.dark-theme .preset-btn:hover {
                background-color: #6b7280 !important;
            }

            /* æ·±è‰²ä¸»é¢˜ä¸‹çš„æ–‡å­—é¢œè‰²ä¿®å¤ */
            body.dark-theme h4,
            body.dark-theme h5,
            body.dark-theme h1,
            body.dark-theme h3 {
                color: #e9ecef !important;
            }

            body.dark-theme .theme-controls h4 {
                color: #e9ecef !important;
            }

            body.dark-theme .theme-controls h5 {
                color: #e9ecef !important;
            }

            body.dark-theme .theme-controls label {
                color: #e9ecef !important;
            }

            body.dark-theme div[style*="color: #333"] {
                color: #e9ecef !important;
            }

            body.dark-theme div[style*="color: #495057"] {
                color: #e9ecef !important;
            }

            body.dark-theme label[style*="color: #333"] {
                color: #e9ecef !important;
            }

            body.dark-theme label[style*="color: #495057"] {
                color: #e9ecef !important;
            }

            body.dark-theme span[style*="color: #6c757d"] {
                color: #9ca3af !important;
            }

            body.dark-theme div[style*="color: #383d41"] {
                color: #e9ecef !important;
            }

            body.dark-theme h5[style*="color: #495057"] {
                color: #e9ecef !important;
            }

            body.dark-theme h5[style*="color: #383d41"] {
                color: #e9ecef !important;
            }

            body.dark-theme h4[style*="color: #333"] {
                color: #e9ecef !important;
            }

            body.dark-theme strong[style*="color: #333"] {
                color: #e9ecef !important;
            }

  
            /* ä¸»é¢˜è¿‡æ¸¡åŠ¨ç”» */
            body {
                transition: background-color 0.3s ease, color 0.3s ease;
            }

            .container,
            .controls,
            .layer-panel,
            .alliance-panel,
            .canvas-container,
            input,
            select,
            textarea,
            button {
                transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
            }
        </style>
    </head>

    <body>
        <div class="container">
            <!-- ç¬¬1åˆ—ï¼šå‚æ•° + æŒ‰é’® -->
            <div class="controls">
                <div class="input-group">
                    <label for="mapWidth">åœ°å›¾å®½åº¦ (åƒç´ ):</label>
                    <input type="number" id="mapWidth" value="1199" min="100" max="2000">
                    <small class="input-hint">èŒƒå›´: 100-2000åƒç´ ï¼ˆ1199 è¡¨ç¤º 0..1199ï¼‰</small>
                </div>
                <div class="input-group">
                    <label for="mapHeight">åœ°å›¾é«˜åº¦ (åƒç´ ):</label>
                    <input type="number" id="mapHeight" value="1199" min="100" max="2000">
                    <small class="input-hint">èŒƒå›´: 100-2000åƒç´ ï¼ˆ1199 è¡¨ç¤º 0..1199ï¼‰</small>
                </div>
                <div class="input-group">
                    <label for="cellSize">æ ¼å­è¾¹é•¿ (åƒç´ ):</label>
                    <input type="number" id="cellSize" value="100" min="1">
                    <small class="input-hint">æœ€å°å€¼: 1åƒç´ ï¼ˆå¿…é¡»æ˜¯æ•´æ•°ï¼‰</small>
                </div>

                <!-- ç½‘æ ¼çº¿æ§åˆ¶ç»„ä»¶ -->
                <div class="grid-controls">
                    <h4 style="margin: 15px 0 10px 0; color: #333; font-size: 14px;">ç½‘æ ¼çº¿è®¾ç½®</h4>
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                        <input type="checkbox" id="showGridLines" style="width: 14px; height: 14px;">
                        <label for="showGridLines" style="font-size: 13px; color: #333; margin: 0;">æ˜¾ç¤ºç½‘æ ¼çº¿</label>
                    </div>
                    <div id="gridLineOptions" style="margin-left: 24px; display: none;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                            <label style="font-size: 12px; color: #666; min-width: 60px;">é¢œè‰²:</label>
                            <input type="color" id="gridLineColor" value="#cccccc" style="width: 50px; height: 24px; border: 1px solid #ddd; border-radius: 3px;">
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                            <label style="font-size: 12px; color: #666; min-width: 60px;">ç²—ç»†:</label>
                            <input type="range" id="gridLineWidth" min="1" max="5" value="1" style="width: 80px;">
                            <span id="gridLineWidthValue" style="font-size: 12px; color: #666; min-width: 20px;">1px</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                            <label style="font-size: 12px; color: #666; min-width: 60px;">é€æ˜åº¦:</label>
                            <input type="range" id="gridLineOpacity" min="10" max="100" value="50" style="width: 80px;">
                            <span id="gridLineOpacityValue" style="font-size: 12px; color: #666; min-width: 35px;">50%</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                            <label style="font-size: 12px; color: #666; min-width: 60px;">å±‚çº§:</label>
                            <select id="gridLineLayer" style="width: 80px; padding: 2px; border: 1px solid #ddd; border-radius: 3px; font-size: 12px;">
                                <option value="bottom">åº•å±‚</option>
                                <option value="middle" selected>ä¸­å±‚</option>
                                <option value="top">é¡¶å±‚</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="button-group">
                    <button id="generateBtn">ç”Ÿæˆåœ°å›¾</button>
                </div>

                <!-- ä¸»é¢˜åˆ‡æ¢åŠŸèƒ½ -->
                <div class="theme-controls" style="margin-top: 20px;">
                    <h4 style="margin: 15px 0 10px 0; color: #333; font-size: 14px;">ä¸»é¢˜è®¾ç½®</h4>

                    <!-- ç•Œé¢ä¸»é¢˜åˆ‡æ¢ -->
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 5px; margin-bottom: 12px;">
                        <h5 style="margin: 0 0 8px 0; color: #495057; font-size: 13px;">ç•Œé¢ä¸»é¢˜</h5>
                        <div style="display: flex; flex-direction: column; gap: 6px;">
                            <label style="display: flex; align-items: center; font-size: 12px; color: #495057;">
                                <input type="radio" name="uiTheme" value="light" checked style="margin-right: 6px;">
                                â˜€ï¸ æµ…è‰²ä¸»é¢˜ï¼ˆé»˜è®¤ï¼‰
                            </label>
                            <label style="display: flex; align-items: center; font-size: 12px; color: #495057;">
                                <input type="radio" name="uiTheme" value="dark" style="margin-right: 6px;">
                                ğŸŒ™ æ·±è‰²ä¸»é¢˜
                            </label>
                        </div>
                    </div>

                    <!-- æ ¼å­é¢œè‰²ä¸»é¢˜ -->
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 5px; margin-bottom: 12px;">
                        <h5 style="margin: 0 0 8px 0; color: #495057; font-size: 13px;">æ ¼å­é¢œè‰²ä¸»é¢˜</h5>
                        <div style="display: flex; flex-direction: column; gap: 6px;">
                            <label style="display: flex; align-items: center; font-size: 12px; color: #495057;">
                                <input type="radio" name="cellTheme" value="default" checked style="margin-right: 6px;">
                                ğŸ¨ é»˜è®¤é…è‰²ï¼ˆç°ç™½æ ¼å­ï¼‰
                            </label>
                              <label style="display: flex; align-items: center; font-size: 12px; color: #495057;">
                                <input type="radio" name="cellTheme" value="spring" style="margin-right: 6px;">
                                ğŸŒ¸ æ˜¥å­£ä¸»é¢˜ï¼ˆç²‰ç»¿é…è‰²ï¼‰
                            </label>
                            <label style="display: flex; align-items: center; font-size: 12px; color: #495057;">
                                <input type="radio" name="cellTheme" value="summer" style="margin-right: 6px;">
                                â˜€ï¸ å¤å­£ä¸»é¢˜ï¼ˆè“é»„é…è‰²ï¼‰
                            </label>
                            <label style="display: flex; align-items: center; font-size: 12px; color: #495057;">
                                <input type="radio" name="cellTheme" value="autumn" style="margin-right: 6px;">
                                ğŸ‚ ç§‹å­£ä¸»é¢˜ï¼ˆæ©™æ£•é…è‰²ï¼‰
                            </label>
                            <label style="display: flex; align-items: center; font-size: 12px; color: #495057;">
                                <input type="radio" name="cellTheme" value="winter" style="margin-right: 6px;">
                                â„ï¸ å†¬å­£ä¸»é¢˜ï¼ˆè“ç™½é…è‰²ï¼‰
                            </label>
                        </div>
                    </div>
                </div>

                <div class="info-panel">
                    <h3>æ ¼å­ä¿¡æ¯</h3>
                    <p id="cellInfo">ç‚¹å‡»æ ¼å­æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯</p>
                </div>

            </div>

            <!-- ç¬¬2åˆ—ï¼šåœˆå±‚åˆ—è¡¨ï¼ˆå¤šé€‰ï¼‰ + æŒ‰ç±»å‹çš„èµ„æº/æ€ªç‰©åˆ—è¡¨ï¼ˆå¤šé€‰ï¼‰ -->
            <div class="layer-panel">
                <div class="layer-controls">
                    <label for="layerSelect">åœˆå±‚åˆ—è¡¨ï¼ˆå¤šé€‰ï¼‰</label>
                    <select id="layerSelect" multiple></select>
                    <div style="display:flex; gap:8px; margin-top:8px;">
                        <button id="highlightBtn">é«˜äº®é€‰æ‹©</button>
                        <button id="clearHighlightBtn">æ¸…é™¤é«˜äº®</button>
                    </div>
                    <hr style="margin:12px 0;">

                    <label for="monsterSelect" style="margin-top:8px;">æ€ªç‰©åˆ—è¡¨ï¼ˆç±»å‹1ï¼Œå¯å¤šé€‰ï¼‰</label>
                    <select id="monsterSelect" multiple></select>
                    <div style="display:flex; gap:8px; margin-top:8px; align-items:center;">
                        <label style="font-size:13px;color:#333;">æ€ªç‰©æ•°é‡ï¼š</label>
                        <input id="monsterQuantity" type="number" value="1" placeholder="æ­£æ•°æ·»åŠ ï¼Œè´Ÿæ•°ç§»é™¤"
                            style="width:80px;padding:6px;border:1px solid #ddd;border-radius:4px;">
                        <button id="setMonsterQtyBtn"
                            style="background:#007bff;color:#fff;padding:6px 8px;border-radius:4px;">è®¾ç½®</button>
                    </div>
                    <div style="display:flex; gap:8px; margin-top:8px; flex-wrap:wrap;">
                        <button id="applyMonsterBtn">æ€ªç‰©åˆ°åœˆå±‚</button>
                        <button id="applyMonsterToCellBtn">æ€ªç‰©åˆ°æ ¼å­</button>
                    </div>

                    <hr style="margin:12px 0;">

                    <label for="resourceSelect" style="margin-top:8px;">èµ„æºåˆ—è¡¨ï¼ˆç±»å‹2ï¼Œå¯å¤šé€‰ï¼‰</label>
                    <select id="resourceSelect" multiple></select>
                    <div style="display:flex; gap:8px; margin-top:8px; align-items:center;">
                        <label style="font-size:13px;color:#333;">èµ„æºæ•°é‡ï¼š</label>
                        <input id="resourceQuantity" type="number" value="1" placeholder="æ­£æ•°æ·»åŠ ï¼Œè´Ÿæ•°ç§»é™¤"
                            style="width:80px;padding:6px;border:1px solid #ddd;border-radius:4px;">
                        <button id="setResourceQtyBtn"
                            style="background:#007bff;color:#fff;padding:6px 8px;border-radius:4px;">è®¾ç½®</button>
                    </div>
                    <div style="display:flex; gap:8px; margin-top:8px; flex-wrap:wrap;">
                        <button id="applyResourceBtn">èµ„æºåˆ°åœˆå±‚</button>
                        <!-- æ–°å¢ï¼šç›´æ¥æ·»åŠ åˆ°å½“å‰é€‰ä¸­æ ¼å­çš„æŒ‰é’® -->
                        <button id="applyResourceToCellBtn">èµ„æºåˆ°æ ¼å­</button>
                    </div>
                    <hr style="margin:10px 0;">
                </div>
            </div>

            <!-- ç¬¬3åˆ—ï¼šç”»å¸ƒ -->
            <div class="canvas-container">
                <!-- åŠ è½½åŠ¨ç”»æŒ‡ç¤ºå™¨ -->
                <div id="loadingIndicator" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); text-align: center; z-index: 1000;">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div class="spinner" style="width: 24px; height: 24px; border: 3px solid #f3f3f3; border-top: 3px solid #007bff; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        <div>
                            <h4 style="margin: 0 0 8px 0; color: #333;">æ­£åœ¨ç”Ÿæˆåœ°å›¾...</h4>
                            <div style="font-size: 14px; color: #666;">å·²å®Œæˆï¼š<span id="loadingProgress">0</span>%</div>
                            <div style="width: 200px; height: 6px; background: #f0f0f0; border-radius: 3px; margin-top: 10px; overflow: hidden;">
                                <div id="loadingBar" style="height: 100%; background: linear-gradient(90deg, #007bff, #28a745); width: 0%; transition: width 0.3s ease; border-radius: 3px;"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <canvas id="mapCanvas"></canvas>

                <!-- å¯¼å‡ºå’ŒæŸ¥æ‰¾æŒ‰é’®ç»„ - å·¦å³å¯¹é½æ˜¾ç¤º -->
                <div
                    style="display: flex; justify-content: space-between; align-items: center; margin-top: 15px; width: 100%; min-width: 600px;">
                    <!-- å·¦ä¾§ï¼šå¯¼å‡ºæŒ‰é’® -->
                    <div style="display: flex; gap: 15px; align-items: center; flex-shrink: 0;">
                        <button id="printBtn">æ‰“å°æ ¼å­åæ ‡æ•°æ®</button>
                        <button id="exportResourceBtn">(æ€ªå…ˆ,ç©ºè¡Œ,èµ„æº)å¯¼å‡º</button>
                    </div>

                    <!-- å³ä¾§ï¼šåæ ‡æŸ¥æ‰¾ -->
                    <div style="display: flex; gap: 10px; align-items: center; flex-shrink: 0;">
                        <label style="font-size: 14px; color: #333; white-space: nowrap;">åæ ‡æŸ¥æ‰¾ï¼š</label>
                        <input type="text" id="coordinateInput" placeholder="X;Y"
                            style="width: 100px; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                        <button id="findCellBtn"
                            style="background: #007bff; color: white; padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;">æŸ¥æ‰¾</button>
                        <button id="clearSearchBtn"
                            style="background: #6c757d; color: white; padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;">æ¸…é™¤</button>
                    </div>
                </div>

                <!-- åæ ‡æŸ¥æ‰¾ç»“æœæ˜¾ç¤ºåŒºåŸŸ -->
                <div id="coordinateSearchResult"
                    style="margin-top: 10px; text-align: center; font-size: 14px; color: #333; min-height: 14px;"></div>
            </div>

            <!-- ç¬¬4åˆ—ï¼šè”ç›Ÿèµ„æºé…ç½® -->
            <div class="alliance-panel">
                <h3 style="margin-bottom: 15px; color: #333; font-size: 16px;">è”ç›Ÿèµ„æºé…ç½®</h3>

                <!-- å‰”é™¤åŠŸèƒ½æŒ‰é’® -->
                <div style="margin-bottom: 15px;">
                    <button id="excludeBtn"
                        style="background: #ffc107; color: #000; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; width: 100%; margin-bottom: 8px;">
                        å‰”é™¤æ ¼å­ï¼ˆæ¿€æ´»åæ ‡é»„ï¼‰
                    </button>
                    <button id="clearExcludeBtn"
                        style="background: #6c757d; color: #fff; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; width: 100%;">
                        æ¸…é™¤å‰”é™¤
                    </button>
                </div>

                <!-- è”ç›Ÿèµ„æºæ•°é‡è¾“å…¥ -->
                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #333; font-size: 14px;">èµ„æºæ•°é‡è®¾ç½®</h4>
                    <div style="display: flex; align-items: center; margin-bottom: 10px;">
                        <label for="allianceFarm" style="margin-right: 10px; min-width: 110px;">å†œåœºæ•°é‡ï¼š</label>
                        <input type="number" id="allianceFarm" value="0" min="0" style="width: 80px; padding: 6px;">
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 10px;">
                        <label for="allianceWood" style="margin-right: 10px; min-width: 110px;">ä¼æœ¨å‚æ•°é‡ï¼š</label>
                        <input type="number" id="allianceWood" value="0" min="0" style="width: 80px; padding: 6px;">
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 10px;">
                        <label for="allianceMine" style="margin-right: 10px; min-width: 110px;">ç…¤çŸ¿å‚æ•°é‡ï¼š</label>
                        <input type="number" id="allianceMine" value="0" min="0" style="width: 80px; padding: 6px;">
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 10px;">
                        <label for="allianceIron" style="margin-right: 10px; min-width: 110px;">é“çŸ¿å‚æ•°é‡ï¼š</label>
                        <input type="number" id="allianceIron" value="0" min="0" style="width: 80px; padding: 6px;">
                    </div>
                </div>

                <!-- èµ„æºåŠå¾„é™åˆ¶ -->
                <div class="input-group">
                    <label for="resourceRadius">èµ„æºåŠå¾„é™åˆ¶ï¼ˆåƒç´ ï¼‰ï¼š</label>
                    <input type="number" id="resourceRadius" value="10" min="0">
                    <small class="input-hint">0=æ— é™åˆ¶</small>
                </div>

                <!-- ç”Ÿæˆè”ç›Ÿèµ„æºæŒ‰é’® -->
                <div class="button-group" style="margin-top: 15px;">
                    <button id="generateAllianceBtn" style="background: #28a745; color: #fff;">
                        ç”Ÿæˆèµ„æº
                    </button>
                    <button id="clearAllianceBtn" style="background: #dc3545; color: #fff;">
                        æ¸…é™¤èµ„æº
                    </button>
                </div>

                <!-- èµ„æºç»Ÿè®¡æ˜¾ç¤º -->
                <div id="resourceStats"
                    style="background: #e9ecef; padding: 10px; border-radius: 4px; font-size: 13px; margin-top: 15px; display: none;">
                    <div id="statsContent"></div>
                </div>

                <!-- æ ¼å­å†…èµ„æºç‚¹åæ ‡æ˜¾ç¤º -->
                <div id="cellResourceCoords" style="margin-top: 15px; display: none;">
                    <h4 style="margin: 0 0 10px 0; color: #333; font-size: 14px;">æ ¼å­å†…èµ„æºåæ ‡ï¼š</h4>
                    <div id="resourceCoordsList"
                        style="background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 12px; max-height: 200px; overflow-y: auto;">
                    </div>
                </div>

                <!-- åˆ†éš”çº¿ -->
                <hr style="margin: 20px 0; border: none; border-top: 2px solid #dee2e6;">

                <!-- èµ„æºé¢„è§ˆå’Œåˆ†æåŠŸèƒ½ -->
                <div style="margin-top: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px;">èµ„æºé¢„è§ˆä¸åˆ†æ</h4>

                    <!-- é¢„è§ˆåŠŸèƒ½æŒ‰é’® -->
                    <div style="margin-bottom: 15px;">
                        <button id="previewResourcesBtn" style="background: #17a2b8; color: #fff; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; width: 100%; margin-bottom: 8px;">
                            ğŸ” èµ„æºé¢„è§ˆ
                        </button>
                        <button id="conflictDetectionBtn" style="background: #fd7e14; color: #fff; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; width: 100%; margin-bottom: 8px;">
                            âš ï¸ å†²çªæ£€æµ‹
                        </button>
                        <button id="advancedStatsBtn" style="background: #6610f2; color: #fff; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; width: 100%;">
                            ğŸ“Š é«˜çº§ç»Ÿè®¡
                        </button>
                    </div>

                    <!-- é¢„è§ˆç»“æœæ˜¾ç¤ºåŒºåŸŸ -->
                    <div id="resourcePreviewPanel" style="display: none;">
                        <!-- èµ„æºç±»å‹é€‰æ‹©å™¨ -->
                        <div style="background: #e9ecef; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                            <h5 style="margin: 0 0 8px 0; color: #495057; font-size: 14px;">èµ„æºç±»å‹ç­›é€‰</h5>
                            <div style="display: flex; flex-direction: column; gap: 6px;">
                                <label style="display: flex; align-items: center; font-size: 12px; color: #495057;">
                                    <input type="radio" name="heatmapFilter" value="all" checked style="margin-right: 6px;">
                                    æ˜¾ç¤ºæ‰€æœ‰èµ„æº
                                </label>
                                <label style="display: flex; align-items: center; font-size: 12px; color: #495057;">
                                    <input type="radio" name="heatmapFilter" value="1" style="margin-right: 6px;">
                                    åªæ˜¾ç¤ºæ€ªç‰© (type=1)
                                </label>
                                <label style="display: flex; align-items: center; font-size: 12px; color: #495057;">
                                    <input type="radio" name="heatmapFilter" value="2" style="margin-right: 6px;">
                                    åªæ˜¾ç¤ºèµ„æº (type=2)
                                </label>
                                <label style="display: flex; align-items: center; font-size: 12px; color: #495057;">
                                    <input type="radio" name="heatmapFilter" value="3" style="margin-right: 6px;">
                                    åªæ˜¾ç¤ºè”ç›Ÿèµ„æº (type=3)
                                </label>
                            </div>
                        </div>

                        <div style="background: #f8f9fa; padding: 12px; border-radius: 5px; margin-bottom: 10px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <h5 style="margin: 0; color: #495057; font-size: 14px;">èµ„æºå¯†åº¦çƒ­åŠ›å›¾</h5>
                                <span id="heatmapLegend" style="font-size: 11px; color: #6c757d;">ä½ â†’ é«˜</span>
                            </div>
                            <div id="densityMapContainer" style="width: 100%; height: 120px; background: #fff; border: 1px solid #dee2e6; border-radius: 3px; display: flex; align-items: center; justify-content: center; color: #6c757d; font-size: 12px;">
                                ç‚¹å‡»"èµ„æºé¢„è§ˆ"ç”Ÿæˆå¯†åº¦å›¾
                            </div>
                        </div>

                        <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin-bottom: 10px; border-left: 4px solid #ffc107;">
                            <h5 style="margin: 0 0 5px 0; color: #856404; font-size: 13px;">è°ƒæ•´å»ºè®®</h5>
                            <div id="optimizationSuggestions" style="font-size: 12px; color: #856404; line-height: 1.4;">
                                ç­‰å¾…åˆ†æ...
                            </div>
                        </div>
                    </div>

                    <!-- å†²çªæ£€æµ‹ç»“æœæ˜¾ç¤º -->
                    <div id="conflictDetectionPanel" style="display: none;">
                        <div style="background: #f8d7da; padding: 12px; border-radius: 5px; margin-bottom: 10px; border-left: 4px solid #dc3545;">
                            <h5 style="margin: 0 0 8px 0; color: #721c24; font-size: 14px;">å†²çªæ£€æµ‹ç»“æœ</h5>
                            <div id="conflictReport" style="font-size: 12px; color: #721c24; line-height: 1.4;">
                                æ­£åœ¨æ£€æµ‹å†²çª...
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button id="autoResolveConflictsBtn" style="background: #28a745; color: #fff; padding: 6px 10px; border: none; border-radius: 3px; cursor: pointer; font-size: 12px; flex: 1;">
                                âœ… è‡ªåŠ¨è§£å†³
                            </button>
                            <button id="manualAdjustBtn" style="background: #007bff; color: #fff; padding: 6px 10px; border: none; border-radius: 3px; cursor: pointer; font-size: 12px; flex: 1;">
                                ğŸ”§ æ‰‹åŠ¨è°ƒæ•´
                            </button>
                        </div>
                    </div>

                    <!-- é«˜çº§ç»Ÿè®¡ç»“æœæ˜¾ç¤º -->
                    <div id="advancedStatsPanel" style="display: none;">
                        <div style="background: #d1ecf1; padding: 12px; border-radius: 5px; margin-bottom: 10px; border-left: 4px solid #17a2b8;">
                            <h5 style="margin: 0 0 8px 0; color: #0c5460; font-size: 14px;">è¯¦ç»†ç»Ÿè®¡ä¿¡æ¯</h5>
                            <div id="detailedStats" style="font-size: 12px; color: #0c5460; line-height: 1.4;">
                                æ­£åœ¨ç”Ÿæˆç»Ÿè®¡æŠ¥å‘Š...
                            </div>
                        </div>

                        <!-- å¯è§†åŒ–å›¾è¡¨åŒºåŸŸ -->
                        <div style="background: #f8f9fa; padding: 12px; border-radius: 5px; margin-bottom: 10px;">
                            <h5 style="margin: 0 0 8px 0; color: #495057; font-size: 14px;">å¯è§†åŒ–å›¾è¡¨</h5>
                            <div id="chartContainer" style="width: 100%; height: 150px; background: #fff; border: 1px solid #dee2e6; border-radius: 3px; display: flex; align-items: center; justify-content: center;">
                                <canvas id="statsChart" style="width: 100%; height: 100%; display: none;"></canvas>
                                <span id="chartPlaceholder" style="color: #6c757d; font-size: 12px;">ç‚¹å‡»"é«˜çº§ç»Ÿè®¡"ç”Ÿæˆå›¾è¡¨</span>
                            </div>
                        </div>

                        <!-- åœˆå±‚åˆ†æ -->
                        <div style="background: #e2e3e5; padding: 12px; border-radius: 5px; margin-bottom: 10px;">
                            <h5 style="margin: 0 0 8px 0; color: #383d41; font-size: 14px;">åœˆå±‚åˆ†æ</h5>
                            <div id="layerAnalysis" style="font-size: 12px; color: #383d41; line-height: 1.4;">
                                æ­£åœ¨åˆ†æåœˆå±‚åˆ†å¸ƒ...
                            </div>
                        </div>

                        <!-- å¯¼å‡ºæŠ¥å‘ŠæŒ‰é’® -->
                        <button id="exportReportBtn" style="background: #6f42c1; color: #fff; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; width: 100%;">
                            ğŸ“„ å¯¼å‡ºè¯¦ç»†æŠ¥å‘Š
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- å…ˆå¼•å…¥èµ„æºæ•°æ®è„šæœ¬ï¼ˆåŒæ­¥å®šä¹‰å…¨å±€ MAP_RESOURCESï¼‰ï¼Œé¿å… fetch -->
        <script src="map-resources.js"></script>

        <script>
            class MapTools {
                constructor() {
                    this.canvas = document.getElementById('mapCanvas');
                    this.ctx = this.canvas.getContext('2d');
                    this.canvasContainer = document.querySelector('.canvas-container');
                    this.cells = [];
                    this.selectedCell = null;
                    this.zoom = 1;
                    this.mapWidth = 800;  // ç”¨æˆ·è¾“å…¥ï¼Œè¡¨ç¤ºæœ€å¤§åæ ‡ï¼ˆä¾‹å¦‚ 1199 è¡¨ç¤º 0..1199ï¼‰
                    this.mapHeight = 600; // ç”¨æˆ·è¾“å…¥ï¼Œè¡¨ç¤ºæœ€å¤§åæ ‡
                    this.cellSize = 100;
                    this.mapAngle = 0; // 0 or 45

                    // å®é™…åƒç´ å®½é«˜ï¼ˆå› ä¸ºåæ ‡ä»0å¼€å§‹ï¼Œé•¿åº¦ = maxCoord + 1ï¼‰
                    this.actualMapWidth = this.mapWidth + 1;
                    this.actualMapHeight = this.mapHeight + 1;

                    // å½“å‰æ”¯æŒçš„åœˆå±‚æ•°ï¼ˆæ•´æ•°ï¼‰
                    this.maxLayers = 0;

                    // è¢«é€‰ä¸­é«˜äº®çš„åœˆå±‚é›†åˆï¼Œå­˜å‚¨ä¸ºé›¶åŸºç´¢å¼•ï¼ˆlayer å˜é‡ï¼‰
                    this.highlightedLayers = new Set();

                    // åæ ‡æŸ¥æ‰¾é«˜äº®çš„æ ¼å­
                    this.searchHighlightedCell = null;

                    // æ‚¬åœé«˜äº®çš„æ ¼å­
                    this.hoveredCell = null;

                    // åŠ¨ç”»ç›¸å…³
                    this.animationFrame = null;
                    this.animationStartTime = null;

                    // devicePixelRatio æ”¯æŒ
                    this.dpr = window.devicePixelRatio || 1;

                    // æ‹–æ‹½ç›¸å…³
                    this.isDragging = false;
                    this.dragStartX = 0;
                    this.dragStartY = 0;
                    this.mapOffsetX = 0; // CSS åƒç´ 
                    this.mapOffsetY = 0;

                    // èµ„æºç›¸å…³
                    this.allItems = []; // åŸå§‹æ•°ç»„å« type
                    this.monsters = []; // type=1
                    this.resources = []; // type=2
                    this.allianceResources = []; // type=3

                    // å‰”é™¤åŠŸèƒ½ç›¸å…³
                    this.excludeMode = false;
                    this.excludedCells = new Set(); // å­˜å‚¨è¢«å‰”é™¤çš„æ ¼å­ID

                    // ç½‘æ ¼çº¿ç›¸å…³
                    this.showGridLines = false;
                    this.gridLineColor = '#cccccc';
                    this.gridLineWidth = 1;
                    this.gridLineOpacity = 0.5;
                    this.gridLineLayer = 'middle'; // 'bottom', 'middle', 'top'

                    // ä¸»é¢˜ç›¸å…³
                    this.currentUITheme = 'light'; // 'light', 'dark'
                    this.currentCellTheme = 'default'; // 'default', 'spring', 'summer', 'autumn', 'winter'

                    // æ ¼å­é¢œè‰²ä¸»é¢˜é…ç½®
                    this.cellThemes = {
                        default: {
                            odd: '#f9f9f9',
                            even: '#ffffff'
                        },
                                        spring: {
                            odd: '#ffe0f0',  // ç²‰è‰²
                            even: '#e0ffe0'  // æµ…ç»¿è‰²
                        },
                        summer: {
                            odd: '#fff3cd',  // é»„è‰²
                            even: '#d1ecf1'  // æµ…è“è‰²
                        },
                        autumn: {
                            odd: '#ffd4a3',  // æ©™è‰²
                            even: '#d4a373'  // æ£•è‰²
                        },
                        winter: {
                            odd: '#e3f2fd',  // æµ…è“è‰²
                            even: '#f3f4f6'  // ç°ç™½è‰²
                        }
                    };

                    this.initEventListeners();
                    this.loadResourcesFromGlobal();
                    this.loadThemeSettings(); // åŠ è½½ä¿å­˜çš„ä¸»é¢˜è®¾ç½®
                    this.generateMap();
                }

                initEventListeners() {
                    document.getElementById('generateBtn').addEventListener('click', () => {
                        this.generateMap();
                    });


                    document.getElementById('printBtn').addEventListener('click', () => {
                        this.printData();
                    });

                    document.getElementById('highlightBtn').addEventListener('click', () => {
                        this.applyLayerHighlight();
                    });

                    document.getElementById('clearHighlightBtn').addEventListener('click', () => {
                        this.clearLayerHighlight();
                    });

                    document.getElementById('applyMonsterBtn').addEventListener('click', () => {
                        this.applyItemsToSelectedLayers(1);
                    });

                    document.getElementById('applyResourceBtn').addEventListener('click', () => {
                        this.applyItemsToSelectedLayers(2);
                    });

                    // æ–°å¢ï¼šç›´æ¥å°†é€‰ä¸­çš„æ€ªç‰©æ·»åŠ åˆ°å½“å‰é€‰ä¸­çš„æ ¼å­
                    const applyMonsterToCellBtn = document.getElementById('applyMonsterToCellBtn');
                    if (applyMonsterToCellBtn) {
                        applyMonsterToCellBtn.addEventListener('click', () => {
                            this.applyItemsToSelectedCell(1);
                        });
                    }

                    // æ–°å¢ï¼šç›´æ¥å°†é€‰ä¸­çš„èµ„æºæ·»åŠ åˆ°å½“å‰é€‰ä¸­çš„æ ¼å­
                    const applyResourceToCellBtn = document.getElementById('applyResourceToCellBtn');
                    if (applyResourceToCellBtn) {
                        applyResourceToCellBtn.addEventListener('click', () => {
                            this.applyItemsToSelectedCell(2);
                        });
                    }

                    document.getElementById('exportResourceBtn').addEventListener('click', () => {
                        this.exportSeparatedData();
                    });

                    // åæ ‡æŸ¥æ‰¾åŠŸèƒ½
                    document.getElementById('findCellBtn').addEventListener('click', () => {
                        this.findCellByCoordinate();
                    });

                    // åæ ‡è¾“å…¥æ¡†å›è½¦æŸ¥æ‰¾
                    document.getElementById('coordinateInput').addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            this.findCellByCoordinate();
                        }
                    });

                    // æ¸…é™¤æŸ¥æ‰¾ç»“æœ
                    document.getElementById('clearSearchBtn').addEventListener('click', () => {
                        this.clearCoordinateSearch();
                    });

                    // ç½‘æ ¼çº¿æ§åˆ¶äº‹ä»¶ç›‘å¬å™¨
                    document.getElementById('showGridLines').addEventListener('change', (e) => {
                        this.showGridLines = e.target.checked;
                        document.getElementById('gridLineOptions').style.display = this.showGridLines ? 'block' : 'none';
                        this.drawMap();
                    });

                    document.getElementById('gridLineColor').addEventListener('input', (e) => {
                        this.gridLineColor = e.target.value;
                        this.drawMap();
                    });

                    document.getElementById('gridLineWidth').addEventListener('input', (e) => {
                        this.gridLineWidth = parseInt(e.target.value);
                        document.getElementById('gridLineWidthValue').textContent = `${this.gridLineWidth}px`;
                        this.drawMap();
                    });

                    document.getElementById('gridLineOpacity').addEventListener('input', (e) => {
                        this.gridLineOpacity = parseInt(e.target.value) / 100;
                        document.getElementById('gridLineOpacityValue').textContent = `${e.target.value}%`;
                        this.drawMap();
                    });

                    document.getElementById('gridLineLayer').addEventListener('change', (e) => {
                        this.gridLineLayer = e.target.value;
                        this.drawMap();
                    });

                    // è”ç›Ÿèµ„æºç›¸å…³äº‹ä»¶ç›‘å¬å™¨
                    document.getElementById('excludeBtn').addEventListener('click', () => {
                        this.toggleExcludeMode();
                    });
                    document.getElementById('clearExcludeBtn').addEventListener('click', () => {
                        this.clearExcludedCells();
                    });
                    document.getElementById('generateAllianceBtn').addEventListener('click', () => {
                        this.generateAllianceResources();
                    });
                    document.getElementById('clearAllianceBtn').addEventListener('click', () => {
                        this.clearAllianceResources();
                    });

                    // èµ„æºé¢„è§ˆå’Œåˆ†æåŠŸèƒ½äº‹ä»¶ç›‘å¬å™¨
                    document.getElementById('previewResourcesBtn').addEventListener('click', () => {
                        this.previewResources();
                    });

                    // èµ„æºç±»å‹ç­›é€‰äº‹ä»¶ç›‘å¬å™¨
                    document.querySelectorAll('input[name="heatmapFilter"]').forEach(radio => {
                        radio.addEventListener('change', () => {
                            this.generateDensityMap();
                        });
                    });

                    // ä¸»é¢˜åˆ‡æ¢äº‹ä»¶ç›‘å¬å™¨
                    document.querySelectorAll('input[name="uiTheme"]').forEach(radio => {
                        radio.addEventListener('change', (e) => {
                            this.switchUITheme(e.target.value);
                        });
                    });

                    // æ ¼å­é¢œè‰²ä¸»é¢˜åˆ‡æ¢äº‹ä»¶ç›‘å¬å™¨
                    document.querySelectorAll('input[name="cellTheme"]').forEach(radio => {
                        radio.addEventListener('change', (e) => {
                            this.switchCellTheme(e.target.value);
                        });
                    });

                      document.getElementById('conflictDetectionBtn').addEventListener('click', () => {
                        this.detectResourceConflicts();
                    });
                    document.getElementById('advancedStatsBtn').addEventListener('click', () => {
                        this.showAdvancedStatistics();
                    });
                    document.getElementById('autoResolveConflictsBtn').addEventListener('click', () => {
                        this.autoResolveConflicts();
                    });
                    document.getElementById('manualAdjustBtn').addEventListener('click', () => {
                        this.startManualAdjustment();
                    });
                    document.getElementById('exportReportBtn').addEventListener('click', () => {
                        this.exportDetailedReport();
                    });

                    // Set quantity buttons for batch or single selection edits
                    document.getElementById('setMonsterQtyBtn').addEventListener('click', () => {
                        this.setItemQuantity(1);
                    });
                    document.getElementById('setResourceQtyBtn').addEventListener('click', () => {
                        this.setItemQuantity(2);
                    });

                    // synchronize select -> quantity input when selection changes
                    document.getElementById('monsterSelect').addEventListener('change', () => {
                        this.syncQuantityInputFromSelection(1);
                    });
                    document.getElementById('resourceSelect').addEventListener('change', () => {
                        this.syncQuantityInputFromSelection(2);
                    });

                    // unified event to map coordinate
                    this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                    this.canvas.addEventListener('mousemove', (e) => this.handleCanvasHover(e));

                    // dragging
                    this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                    this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                    this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                    this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                    this.canvas.addEventListener('mouseleave', (e) => this.handleMouseLeave(e));

                    // resize / dpr change
                    window.addEventListener('resize', () => {
                        this.dpr = window.devicePixelRatio || 1;
                        this.updateCanvasSize();
                        this.drawMap();
                    });
                }

                loadResourcesFromGlobal() {
                    // è¯»å–å…¨å±€ MAP_RESOURCESï¼ˆç”± map-resources.js æä¾›ï¼‰
                    if (window.MAP_RESOURCES && Array.isArray(window.MAP_RESOURCES)) {
                        // ä¿ç•™åŸå§‹æ•°é‡ï¼Œæ”¯æŒè´Ÿæ•°ç”¨äºç§»é™¤èµ„æºï¼Œé»˜è®¤ 0
                        this.allItems = window.MAP_RESOURCES.map(i => {
                            const q = (i.qty != null) ? parseInt(i.qty) : 0;
                            const safeQ = isNaN(q) ? 0 : q; // å…è®¸è´Ÿæ•°
                            return { id: i.id, name: i.name, type: i.type, qty: safeQ };
                        });
                    } else {
                        this.allItems = [];
                        console.warn('MAP_RESOURCES æœªå®šä¹‰æˆ–æ ¼å¼ä¸å¯¹ï¼Œèµ„æº/æ€ªç‰©åˆ—è¡¨ä¸ºç©ºã€‚');
                    }

                    this.monsters = this.allItems.filter(i => Number(i.type) === 1).map(i => Object.assign({}, i));
                    this.resources = this.allItems.filter(i => Number(i.type) === 2).map(i => Object.assign({}, i));
                    this.allianceResources = this.allItems.filter(i => Number(i.type) === 3).map(i => Object.assign({}, i));

                    this.updateMonsterList();
                    this.updateResourceList();
                }

                updateMonsterList() {
                    const sel = document.getElementById('monsterSelect');
                    sel.innerHTML = '';
                    for (const r of this.monsters) {
                        const opt = document.createElement('option');
                        opt.value = String(r.id);
                        // å­˜å‚¨ qty åˆ° data å±æ€§ï¼Œä¿ç•™åŸå§‹å€¼ï¼ˆåŒ…æ‹¬è´Ÿæ•°ï¼‰
                        const qtyVal = (r.qty != null) ? Number(r.qty) : 0;
                        const qty = isNaN(qtyVal) ? 0 : qtyVal; // å…è®¸è´Ÿæ•°
                        opt.dataset.qty = String(qty);
                        // åœ¨é€‰é¡¹æ–‡æœ¬ä¸­æ˜¾ç¤ºæ•°é‡ï¼ˆåŒ…æ‹¬è´Ÿæ•°ï¼‰
                        opt.text = `${r.name} (${r.id}) (æ•°é‡:${qty})`;
                        sel.appendChild(opt);
                    }
                    // try to sync quantity input when list refreshed
                    this.syncQuantityInputFromSelection(1);
                }

                updateResourceList() {
                    const sel = document.getElementById('resourceSelect');
                    sel.innerHTML = '';
                    for (const r of this.resources) {
                        const opt = document.createElement('option');
                        opt.value = String(r.id);
                        const qtyVal = (r.qty != null) ? Number(r.qty) : 0;
                        const qty = isNaN(qtyVal) ? 0 : qtyVal; // å…è®¸è´Ÿæ•°
                        opt.dataset.qty = String(qty);
                        opt.text = `${r.name} (${r.id}) (æ•°é‡:${qty})`;
                        sel.appendChild(opt);
                    }
                    this.syncQuantityInputFromSelection(2);
                }

                // å½“ç”¨æˆ·åœ¨åˆ—è¡¨ä¸­é€‰æ‹©æ—¶ï¼Œæ›´æ–°"æ¯é¡¹æ•°é‡"è¾“å…¥æ¡†æ˜¾ç¤º
                // è‹¥å¤šé€‰ä¸”æ‰€æœ‰é€‰ä¸­é¡¹çš„æ•°é‡ç›¸åŒï¼Œåˆ™æ˜¾ç¤ºè¯¥æ•°é‡ï¼›å¦åˆ™æ¸…ç©ºè¾“å…¥æ¡†ä»¥æç¤ºç”¨æˆ·è¿™æ˜¯æ··åˆå€¼
                syncQuantityInputFromSelection(type) {
                    const select = (type === 1) ? document.getElementById('monsterSelect') : document.getElementById('resourceSelect');
                    const input = (type === 1) ? document.getElementById('monsterQuantity') : document.getElementById('resourceQuantity');
                    const selectedOptions = Array.from(select.selectedOptions || []);
                    if (selectedOptions.length === 0) {
                        // show nothing / keep default
                        // do not override user manual edits if none selected
                        return;
                    }
                    const qtys = selectedOptions.map(opt => {
                        const v = opt.dataset.qty;
                        const n = Number(v);
                        return isNaN(n) ? null : n;
                    });
                    const allSame = qtys.every(q => q === qtys[0]);
                    if (allSame) {
                        input.value = qtys[0] != null ? qtys[0] : '';
                    } else {
                        input.value = '';
                    }
                }

                // å°†è¾“å…¥æ¡†çš„æ•°é‡è®¾ç½®åˆ°é€‰ä¸­çš„åˆ—è¡¨é¡¹ï¼ˆæ”¯æŒå¤šé€‰æ‰¹é‡è®¾ç½®ï¼Œä¹Ÿæ”¯æŒå•ä¸ªè®¾ç½®ï¼Œæ”¯æŒè´Ÿæ•°ï¼‰
                setItemQuantity(type) {
                    const select = (type === 1) ? document.getElementById('monsterSelect') : document.getElementById('resourceSelect');
                    const input = (type === 1) ? document.getElementById('monsterQuantity') : document.getElementById('resourceQuantity');
                    let val = parseInt(input.value);
                    if (isNaN(val)) {
                        alert('è¯·è¾“å…¥æœ‰æ•ˆæ•°é‡ï¼ˆæ•´æ•°ï¼Œæ”¯æŒè´Ÿæ•°ç”¨äºç§»é™¤èµ„æºï¼‰ã€‚');
                        return;
                    }
                    // å…è®¸è´Ÿæ•°ï¼Œç”¨äºç§»é™¤èµ„æº

                    const selOpts = Array.from(select.selectedOptions || []);
                    if (selOpts.length === 0) {
                        alert('è¯·å…ˆåœ¨åˆ—è¡¨ä¸­é€‰æ‹©ä¸€ä¸ªæˆ–å¤šä¸ªé¡¹ï¼Œå†è®¾ç½®æ•°é‡ã€‚');
                        return;
                    }
                    // update underlying data arrays
                    const arr = (type === 1) ? this.monsters : this.resources;
                    for (const opt of selOpts) {
                        const idStr = String(opt.value);
                        opt.dataset.qty = String(val);
                        // æ›´æ–°æ–‡æœ¬æ˜¾ç¤ºï¼Œä¿è¯æ—§æœ‰çš„ (æ•°é‡:...) ä¼šè¢«æ›¿æ¢
                        const base = this._getBaseTextForOption(opt.textContent || '', idStr);
                        opt.text = `${base} (æ•°é‡:${val})`;
                        // æ›´æ–°æ•°ç»„ entry
                        const found = arr.find(a => String(a.id) === idStr);
                        if (found) {
                            found.qty = val;
                        } else {
                            // å¦‚æœæ‰¾ä¸åˆ°ï¼Œæ’å…¥ä¸€é¡¹ï¼ˆä¿å®ˆå¤„ç†ï¼‰
                            arr.push({ id: idStr, name: base.split(' (')[0], type: type, qty: val });
                        }
                    }
                }

                // helper to try to reconstruct base name/id text without existing (æ•°é‡:...) suffix
                _getBaseTextForOption(fullText, idStr) {
                    // fullText might be like: "åå­— (123) (æ•°é‡:5)" or "åå­— (123)"
                    // ensure we return "åå­— (123)"
                    const idToken = `(${idStr})`;
                    const idx = fullText.indexOf(idToken);
                    if (idx >= 0) {
                        return fullText.substring(0, idx + idToken.length).trim();
                    }
                    // fallback
                    return fullText.split('(æ•°é‡:')[0].trim();
                }

                async generateMap() {
                    // read inputs (ç”¨æˆ·è¾“å…¥è¡¨ç¤ºæœ€å¤§åæ ‡å€¼)
                    this.mapWidth = parseInt(document.getElementById('mapWidth').value) || this.mapWidth;
                    this.mapHeight = parseInt(document.getElementById('mapHeight').value) || this.mapHeight;
                    this.cellSize = parseInt(document.getElementById('cellSize').value) || this.cellSize;

                    // æ›´æ–°å®é™…åƒç´ é•¿åº¦ï¼ˆåæ ‡ä»0å¼€å§‹ => é•¿åº¦ = æœ€å¤§åæ ‡ + 1ï¼‰
                    this.actualMapWidth = this.mapWidth + 1;
                    this.actualMapHeight = this.mapHeight + 1;

                    // validate ranges (åŸºäºç”¨æˆ·è¾“å…¥çš„æœ€å¤§åæ ‡)
                    if (this.mapWidth < 100 || this.mapWidth > 2000 ||
                        this.mapHeight < 100 || this.mapHeight > 2000 ||
                        this.cellSize < 1) {
                        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„å‚æ•°èŒƒå›´ï¼š\nåœ°å›¾è¾¹é•¿(æœ€å¤§åæ ‡): 100-2000 åƒç´ \næ ¼å­è¾¹é•¿: æœ€å°1åƒç´ ');
                        return;
                    }

                    if (this.mapAngle !== 0 && this.mapAngle !== 45) {
                        alert('è¯·é€‰æ‹©æœ‰æ•ˆçš„è§’åº¦ï¼š0Â° æˆ– 45Â°');
                        return;
                    }

                    // æ–°å¢æ ¡éªŒï¼šå®é™…åƒç´ é•¿åº¦ (maxCoord + 1) å¿…é¡»èƒ½è¢«æ ¼å­è¾¹é•¿æ•´é™¤ï¼Œå¦åˆ™åœæ­¢ç”Ÿæˆå¹¶æç¤º
                    const msgs = [];
                    if (this.actualMapWidth % this.cellSize !== 0) {
                        msgs.push(`(å®½) å®é™…åƒç´ é•¿åº¦ ${this.actualMapWidth} ä¸èƒ½è¢«æ ¼å­è¾¹é•¿ ${this.cellSize} æ•´é™¤ï¼Œä½™æ•°: ${this.actualMapWidth % this.cellSize}`);
                    }
                    if (this.actualMapHeight % this.cellSize !== 0) {
                        msgs.push(`(é«˜) å®é™…åƒç´ é•¿åº¦ ${this.actualMapHeight} ä¸èƒ½è¢«æ ¼å­è¾¹é•¿ ${this.cellSize} æ•´é™¤ï¼Œä½™æ•°: ${this.actualMapHeight % this.cellSize}`);
                    }
                    if (msgs.length) {
                        alert(msgs.join('\n') + '\nè¯·è°ƒæ•´å‚æ•° (æ³¨æ„ï¼šè¾“å…¥ä¸ºæœ€å¤§åæ ‡ï¼Œå®é™…åƒç´ é•¿åº¦ = æœ€å¤§åæ ‡ + 1)ã€‚');
                        return;
                    }

                    // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
                    this.showLoadingIndicator();

                    // è®¡ç®—è¡Œåˆ—ï¼ˆä½¿ç”¨å®é™…åƒç´ é•¿åº¦ / æ ¼å­å°ºå¯¸ï¼‰
                    this.cols = this.actualMapWidth / this.cellSize;
                    this.rows = this.actualMapHeight / this.cellSize;

                    // æ¨¡æ‹Ÿç”Ÿæˆè¿‡ç¨‹ï¼Œå¸¦è¿›åº¦æ›´æ–°
                    try {
                        await this.generateMapWithProgress();
                    } catch (error) {
                        console.error('åœ°å›¾ç”Ÿæˆå¤±è´¥:', error);
                        alert('åœ°å›¾ç”Ÿæˆè¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œè¯·é‡è¯•ï¼');
                    } finally {
                        this.hideLoadingIndicator();
                    }

                    // è®¡ç®—åœˆå±‚æ•°ï¼ˆæœ€å¤§åœˆå±‚ï¼‰
                    this.maxLayers = Math.ceil(Math.min(this.rows, this.cols) / 2);

                    // åˆå§‹åŒ–å±‚åˆ—è¡¨é€‰æ‹©æ¡†
                    this.updateLayerSelect();

                    // Fit by available viewport height so map shows fully without vertical scroll
                    const viewportHeight = window.innerHeight;
                    const containerRect = this.canvasContainer.getBoundingClientRect();
                    // available height below the top of the canvas container (leave small margin)
                    const availableHeight = Math.max(100, viewportHeight - containerRect.top - 20);

                    // fitZoom based onå®é™…åƒç´ é«˜åº¦
                    const fitZoom = availableHeight / this.actualMapHeight;
                    this.zoom = Math.min(1, fitZoom);

                    // reset highlighted layers when regenerate
                    this.highlightedLayers.clear();
                    this.updateLayerSelectSelection();

                    this.updateCanvasSize();
                    this.drawMap();
                }

                generateCellsSpiral() {
                    this.cells = [];
                    let cellId = 1;
                    const layers = Math.ceil(Math.min(this.rows, this.cols) / 2);

                    for (let layer = 0; layer < layers; layer++) {
                        const topRow = this.rows - 1 - layer;
                        const bottomRow = layer;
                        const leftCol = layer;
                        const rightCol = this.cols - 1 - layer;

                        for (let col = leftCol; col <= rightCol; col++) this.addCell(bottomRow, col, cellId++);
                        for (let row = bottomRow + 1; row <= topRow; row++) this.addCell(row, rightCol, cellId++);
                        for (let col = rightCol - 1; col >= leftCol; col--) this.addCell(topRow, col, cellId++);
                        for (let row = topRow - 1; row > bottomRow; row--) this.addCell(row, leftCol, cellId++);
                    }
                }

                addCell(row, col, id) {
                    const cellSizeMinusOne = this.cellSize - 1;
                    const originalCoordinates = [
                        [col * this.cellSize, row * this.cellSize],
                        [col * this.cellSize, row * this.cellSize + cellSizeMinusOne],
                        [col * this.cellSize + cellSizeMinusOne, row * this.cellSize + cellSizeMinusOne],
                        [col * this.cellSize + cellSizeMinusOne, row * this.cellSize]
                    ];

                    // è®¡ç®—è¯¥æ ¼å­çš„åœˆå±‚ï¼ˆä»0å¼€å§‹ï¼‰
                    const layer = Math.min(row, col, this.rows - 1 - row, this.cols - 1 - col);

                    if (this.mapAngle === 0) {
                        this.cells.push({
                            id, row, col, layer,
                            x: col * this.cellSize,
                            y: row * this.cellSize,
                            coordinates: originalCoordinates,
                            originalCoordinates,
                            resources: []
                        });
                        return;
                    }

                    const angleRad = this.mapAngle * Math.PI / 180;
                    const cosAngle = Math.cos(angleRad);
                    const sinAngle = Math.sin(angleRad);

                    const coordinates = originalCoordinates.map(([x, y]) => {
                        const tx = x * cosAngle - y * sinAngle;
                        const ty = x * sinAngle + y * cosAngle;
                        return [tx, ty];
                    });

                    this.cells.push({
                        id, row, col, layer,
                        x: col * this.cellSize,
                        y: row * this.cellSize,
                        coordinates,
                        originalCoordinates,
                        resources: []
                    });
                }

                updateCanvasSize() {
                    if (this.mapAngle === 0) {
                        const cssWidth = this.actualMapWidth * this.zoom;
                        const cssHeight = this.actualMapHeight * this.zoom;
                        this.canvas.width = Math.round(cssWidth * this.dpr);
                        this.canvas.height = Math.round(cssHeight * this.dpr);
                        this.canvas.style.width = cssWidth + 'px';
                        this.canvas.style.height = cssHeight + 'px';
                        this.mapOffsetX = 0;
                        this.mapOffsetY = 0;
                    } else {
                        const angleRad = -this.mapAngle * Math.PI / 180;
                        const cosAngle = Math.cos(angleRad);
                        const sinAngle = Math.sin(angleRad);

                        const corners = [
                            [0, 0],
                            [0, this.actualMapHeight],
                            [this.actualMapWidth, this.actualMapHeight],
                            [this.actualMapWidth, 0]
                        ];

                        const transformed = corners.map(([x, y]) => {
                            return [x * cosAngle - y * sinAngle, x * sinAngle + y * cosAngle];
                        });

                        const minX = Math.min(...transformed.map(c => c[0]));
                        const maxX = Math.max(...transformed.map(c => c[0]));
                        const minY = Math.min(...transformed.map(c => c[1]));
                        const maxY = Math.max(...transformed.map(c => c[1]));

                        const padding = 20;
                        const cssWidth = (maxX - minX + padding * 2) * this.zoom;
                        const cssHeight = (maxY - minY + padding * 2) * this.zoom;

                        this.canvas.width = Math.round(cssWidth * this.dpr);
                        this.canvas.height = Math.round(cssHeight * this.dpr);
                        this.canvas.style.width = cssWidth + 'px';
                        this.canvas.style.height = cssHeight + 'px';

                        this.mapOffsetX = (-minX + padding) * this.zoom;
                        this.mapOffsetY = (-minY + padding) * this.zoom;
                    }

                    // If canvas CSS width exceeds container, scale CSS down to fit (not internal pixels)
                    const containerRect = this.canvasContainer.getBoundingClientRect();
                    const cssW = parseFloat(this.canvas.style.width) || (this.canvas.width / this.dpr);
                    if (cssW > containerRect.width) {
                        const scale = containerRect.width / cssW;
                        this.canvas.style.width = (cssW * scale) + 'px';
                        this.canvas.style.height = (parseFloat(this.canvas.style.height) * scale) + 'px';
                    }
                }

                drawMap() {
                    // clear internal pixels
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                    // scale for dpr and zoom
                    this.ctx.save();
                    this.ctx.scale(this.dpr, this.dpr);
                    this.ctx.scale(this.zoom, this.zoom);

                    // coordinate origin: left-bottom (ä½¿ç”¨å®é™…é«˜åº¦)
                    this.ctx.translate(0, this.actualMapHeight);
                    this.ctx.scale(1, -1);

                    // apply offset (CSS px units converted by dividing by zoom)
                    if (this.mapOffsetX !== undefined && this.mapOffsetY !== undefined) {
                        this.ctx.translate(this.mapOffsetX / this.zoom, this.mapOffsetY / this.zoom);
                    }

                    // æ ¹æ®å±‚çº§ç»˜åˆ¶ç½‘æ ¼çº¿
                    if (this.showGridLines && this.gridLineLayer === 'bottom') {
                        this.drawGridLines();
                    }

                    // draw cells
                    for (const cell of this.cells) {
                        this.drawCell(cell, cell === this.selectedCell);
                    }

                    // æ ¹æ®å±‚çº§ç»˜åˆ¶ç½‘æ ¼çº¿
                    if (this.showGridLines && this.gridLineLayer === 'top') {
                        this.drawGridLines();
                    }

                    // draw axis
                    this.drawCoordinateAxis();

                    // æ ¹æ®å±‚çº§ç»˜åˆ¶ç½‘æ ¼çº¿
                    if (this.showGridLines && this.gridLineLayer === 'middle') {
                        this.drawGridLines();
                    }

                    this.ctx.restore();
                }

                drawCell(cell, isSelected) {
                    const { coordinates, id, row, col, layer } = cell;

                    // åˆ¤æ–­æ˜¯å¦æ˜¯æŸ¥æ‰¾é«˜äº®çš„æ ¼å­
                    const isSearchHighlighted = this.searchHighlightedCell && this.searchHighlightedCell.id === cell.id;
                    // åˆ¤æ–­æ˜¯å¦æ˜¯æ‚¬åœçš„æ ¼å­
                    const isHovered = this.hoveredCell && this.hoveredCell.id === cell.id;
                    // åˆ¤æ–­æ˜¯å¦æ˜¯èµ„æºåˆ†é…åŠ¨ç”»ä¸­çš„æ ¼å­
                    const isAnimating = cell.isAnimating;
                    const animationProgress = cell.animationProgress || 0;

                    // åŠ¨ç”»æ—¶é—´è®¡ç®—
                    const now = Date.now();
                    let hoverAlpha = 0;
                    if (isHovered && this.hoveredCell) {
                        const hoverDuration = now - this.hoveredCell.hoverStartTime;
                        hoverAlpha = Math.min(1, hoverDuration / 200); // 200msæ·¡å…¥åŠ¨ç”»
                    }

                    // polygon style - æŸ¥æ‰¾é«˜äº®ç”¨è“è‰²ï¼Œæ‰‹åŠ¨é€‰æ‹©ç”¨çº¢è‰²ï¼Œæ‚¬åœç”¨æ©™è‰²ï¼Œèµ„æºåˆ†é…åŠ¨ç”»ç”¨ç´«è‰²
                    if (isSearchHighlighted) {
                        this.ctx.strokeStyle = '#007bff';  // è“è‰²è¾¹æ¡†
                        this.ctx.lineWidth = 3;  // æ›´ç²—çš„è¾¹æ¡†
                    } else if (isAnimating) {
                        // èµ„æºåˆ†é…åŠ¨ç”»ï¼šç´«è‰²è¾¹æ¡†ï¼Œå¸¦è„‰å†²æ•ˆæœ
                        const pulseAlpha = 0.3 + Math.sin(animationProgress * Math.PI * 4) * 0.3;
                        this.ctx.strokeStyle = `rgba(128, 0, 128, ${pulseAlpha})`;
                        this.ctx.lineWidth = 2 + Math.sin(animationProgress * Math.PI * 4) * 1;
                    } else if (isHovered) {
                        this.ctx.strokeStyle = `rgba(255, 140, 0, ${0.5 + hoverAlpha * 0.5})`;  // æ©™è‰²è¾¹æ¡†ï¼Œå¸¦åŠ¨ç”»
                        this.ctx.lineWidth = 2 + hoverAlpha;  // è¾¹æ¡†ç²—ç»†åŠ¨ç”»
                    } else {
                        this.ctx.strokeStyle = isSelected ? '#ff0000' : '#333';
                        this.ctx.lineWidth = isSelected ? 2 : 1;
                    }

                    // determine fill: search highlight -> blue; hover -> orange; selected -> red; excluded -> yellow; highlighted layer -> green; animating -> purple; otherwise checker
                    if (isSearchHighlighted) {
                        this.ctx.fillStyle = 'rgba(0, 123, 255, 0.3)';  // è“è‰²å¡«å……
                    } else if (isAnimating) {
                        // èµ„æºåˆ†é…åŠ¨ç”»ï¼šç´«è‰²å¡«å……ï¼Œå¸¦æ¸å˜æ•ˆæœ
                        const fillAlpha = 0.1 + Math.sin(animationProgress * Math.PI * 2) * 0.1;
                        this.ctx.fillStyle = `rgba(128, 0, 128, ${fillAlpha})`;
                    } else if (isHovered) {
                        this.ctx.fillStyle = `rgba(255, 140, 0, ${0.1 + hoverAlpha * 0.2})`;  // æ©™è‰²å¡«å……ï¼Œå¸¦åŠ¨ç”»
                    } else if (isSelected) {
                        this.ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';  // çº¢è‰²å¡«å……
                    } else if (this.excludedCells && this.excludedCells.has(cell.id)) {
                        this.ctx.fillStyle = 'rgba(255, 235, 59, 0.5)'; // é»„è‰²æ ‡ç¤ºè¢«å‰”é™¤çš„æ ¼å­
                    } else if (this.highlightedLayers && this.highlightedLayers.has(layer)) {
                        this.ctx.fillStyle = 'rgba(0, 128, 0, 0.25)';
                    } else {
                        // ä½¿ç”¨æ ¼å­ä¸»é¢˜é¢œè‰²
                        this.ctx.fillStyle = this.getCellThemeColor(row, col, layer);
                    }

                    // draw polygon (coordinates are in map units)
                    this.ctx.beginPath();
                    this.ctx.moveTo(coordinates[0][0], coordinates[0][1]);
                    for (let i = 1; i < coordinates.length; i++) {
                        this.ctx.lineTo(coordinates[i][0], coordinates[i][1]);
                    }
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();

                    // === dynamic font sizing to avoid overflow ===
                    // compute bounding box of the polygon
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    for (const p of coordinates) {
                        minX = Math.min(minX, p[0]);
                        maxX = Math.max(maxX, p[0]);
                        minY = Math.min(minY, p[1]);
                        maxY = Math.max(maxY, p[1]);
                    }
                    const boxWidth = maxX - minX;
                    const boxHeight = maxY - minY;

                    // padding inside the box (percentage of min dimension)
                    const paddingRatio = 0.12;
                    const padding = Math.max(1, Math.min(boxWidth, boxHeight) * paddingRatio);

                    // choose an initial font size based on boxHeight (map units)
                    const minFont = 6; // minimal readable font in map units
                    const maxFont = Math.max(10, Math.floor(Math.min(boxWidth, boxHeight) * 0.6));
                    let fontSize = Math.min(maxFont, Math.max(minFont, Math.round(boxHeight * 0.5)));

                    // set text properties after flipping back to normal orientation for text measuring/drawing
                    this.ctx.save();
                    // flip so text draws upright (we are in a flipped coordinate system)
                    this.ctx.scale(1, -1);

                    const text = id.toString();
                    const targetMaxWidth = Math.max(1, boxWidth - 2 * padding);

                    // reduce font size until text width fits targetMaxWidth
                    do {
                        this.ctx.font = `${fontSize}px Arial`;
                        const metrics = this.ctx.measureText(text);
                        const textWidth = metrics.width;
                        if (textWidth <= targetMaxWidth) break;
                        fontSize = Math.max(minFont, fontSize - 1);
                    } while (fontSize > minFont);

                    // final draw text centered
                    this.ctx.fillStyle = isSelected ? '#ff0000' : '#666';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    const centerX = (minX + maxX) / 2;
                    const centerY = (minY + maxY) / 2;
                    this.ctx.fillText(text, centerX, -centerY);

                    // å¦‚æœè¯¥æ ¼æœ‰èµ„æºæˆ–æ€ªç‰©ï¼Œåœ¨æ ¼å­ä¸­å¿ƒä¸‹æ–¹æ˜¾ç¤ºç®€çŸ­æ ‡è¯† (æ˜¾ç¤ºå·²åˆ†é…é¡¹æ•°)
                    if (cell.resources && cell.resources.length > 0) {
                        const resText = cell.resources.length > 1 ? `${cell.resources.length}A` : `${cell.resources[0].id}`;
                        // ä½¿ç”¨è¾ƒå°å­—å·æ˜¾ç¤º
                        this.ctx.font = `${Math.max(8, Math.round(fontSize * 0.45))}px Arial`;
                        this.ctx.fillStyle = '#b00000';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'top';
                        // åœ¨ id çš„ä¸‹æ–¹ç”»
                        this.ctx.fillText(resText, centerX, -centerY + Math.max(8, fontSize * 0.6));
                    }

                    this.ctx.restore();
                }

                drawCoordinateAxis() {
                    this.ctx.strokeStyle = '#000';
                    this.ctx.lineWidth = 2;
                    // X axis
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, 0);
                    this.ctx.lineTo(this.actualMapWidth, 0);
                    this.ctx.stroke();
                    // Y axis
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, 0);
                    this.ctx.lineTo(0, this.actualMapHeight);
                    this.ctx.stroke();

                    const fontSize = Math.max(10, Math.min(16, 14 * Math.sqrt(this.zoom)));
                    this.ctx.save();
                    this.ctx.scale(1, -1);
                    this.ctx.fillStyle = '#000';
                    this.ctx.font = `${fontSize}px Arial`;
                    this.ctx.textAlign = 'left';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('0,0', 10, -10);
                    this.ctx.fillText('X', this.actualMapWidth - 15, -10);
                    this.ctx.fillText('Y', 10, -(this.actualMapHeight - 10));
                    this.ctx.restore();
                }

                // ç»˜åˆ¶ç½‘æ ¼çº¿
                drawGridLines() {
                    if (!this.cells || this.cells.length === 0) return;

                    this.ctx.save();

                    // è®¾ç½®ç½‘æ ¼çº¿æ ·å¼
                    this.ctx.strokeStyle = this.hexToRgba(this.gridLineColor, this.gridLineOpacity);
                    this.ctx.lineWidth = this.gridLineWidth;

                    // ç»˜åˆ¶å‚ç›´ç½‘æ ¼çº¿
                    for (let x = 0; x <= this.actualMapWidth; x += this.cellSize) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, 0);
                        this.ctx.lineTo(x, this.actualMapHeight);
                        this.ctx.stroke();
                    }

                    // ç»˜åˆ¶æ°´å¹³ç½‘æ ¼çº¿
                    for (let y = 0; y <= this.actualMapHeight; y += this.cellSize) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, y);
                        this.ctx.lineTo(this.actualMapWidth, y);
                        this.ctx.stroke();
                    }

                    this.ctx.restore();
                }

                // è¾…åŠ©æ–¹æ³•ï¼šå°†åå…­è¿›åˆ¶é¢œè‰²è½¬æ¢ä¸ºRGBA
                hexToRgba(hex, opacity) {
                    // å¦‚æœå·²ç»åŒ…å«rgbï¼Œåˆ™ç›´æ¥å¤„ç†é€æ˜åº¦
                    if (hex.startsWith('rgb')) {
                        return hex.replace('rgb', 'rgba').replace(')', `, ${opacity})`);
                    }

                    // å¤„ç†åå…­è¿›åˆ¶é¢œè‰²
                    let r = 0, g = 0, b = 0;
                    if (hex.length === 4) {
                        r = parseInt(hex[1] + hex[1], 16);
                        g = parseInt(hex[2] + hex[2], 16);
                        b = parseInt(hex[3] + hex[3], 16);
                    } else if (hex.length === 7) {
                        r = parseInt(hex[1] + hex[2], 16);
                        g = parseInt(hex[3] + hex[4], 16);
                        b = parseInt(hex[5] + hex[6], 16);
                    }

                    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                }

                // helper: map event to map coordinates
                getEventMapCoordinates(event) {
                    const rect = this.canvas.getBoundingClientRect();
                    const screenX = event.clientX - rect.left;
                    const screenY = event.clientY - rect.top;
                    return this.screenToMapCoordinates(screenX, screenY, rect);
                }

                // convert CSS pixel coords (relative to canvas) to map coords
                screenToMapCoordinates(screenX, screenY, rect) {
                    if (!rect) rect = this.canvas.getBoundingClientRect();
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;
                    const internalX = screenX * scaleX;
                    const internalY = screenY * scaleY;
                    // internal -> user/map coords (internal units are css*dpr)
                    let x = internalX / (this.dpr * this.zoom);
                    let y = internalY / (this.dpr * this.zoom);
                    // reverse applied offsets and flips
                    x -= this.mapOffsetX / this.zoom;
                    y -= this.mapOffsetY / this.zoom;
                    // ä½¿ç”¨å®é™…é«˜åº¦è¿›è¡Œåè½¬
                    y = this.actualMapHeight - y;
                    if (this.mapAngle !== 0) {
                        const angleRad = -this.mapAngle * Math.PI / 180;
                        const cosA = Math.cos(angleRad);
                        const sinA = Math.sin(angleRad);
                        const rx = x * cosA - y * sinA;
                        const ry = x * sinA + y * cosA;
                        x = rx; y = ry;
                    }
                    return { x, y };
                }

                handleCanvasClick(event) {
                    const { x, y } = this.getEventMapCoordinates(event);
                    const clicked = this.cells.find(cell => this.isPointInPolygon(x, y, cell.coordinates));
                    if (clicked) {
                        // å¦‚æœåœ¨å‰”é™¤æ¨¡å¼ä¸‹ï¼Œåˆ‡æ¢æ ¼å­çš„å‰”é™¤çŠ¶æ€
                        if (this.excludeMode) {
                            if (this.excludedCells.has(clicked.id)) {
                                this.excludedCells.delete(clicked.id);
                            } else {
                                this.excludedCells.add(clicked.id);
                            }
                            this.drawMap();
                        } else {
                            // æ­£å¸¸é€‰æ‹©æ¨¡å¼
                            this.selectedCell = clicked;
                            this.updateCellInfo(clicked);
                            this.drawMap();
                        }
                    }
                }

                handleCanvasHover(event) {
                    const { x, y } = this.getEventMapCoordinates(event);
                    const hovered = this.cells.find(cell => this.isPointInPolygon(x, y, cell.coordinates));
                    this.canvas.style.cursor = hovered ? 'pointer' : 'crosshair';

                    // æ›´æ–°æ‚¬åœæ ¼å­çŠ¶æ€
                    const previousHovered = this.hoveredCell;

                    if (hovered && (!this.hoveredCell || this.hoveredCell.id !== hovered.id)) {
                        this.hoveredCell = {
                            ...hovered,
                            hoverStartTime: Date.now()
                        };
                        // å¯åŠ¨åŠ¨ç”»å¾ªç¯
                        this.startAnimationLoop();
                    } else if (!hovered && this.hoveredCell) {
                        this.hoveredCell = null;
                        // æ£€æŸ¥æ˜¯å¦éœ€è¦ç»§ç»­åŠ¨ç”»å¾ªç¯
                        this.checkAnimationLoop();
                    }
                }

                isPointInPolygon(x, y, polygon) {
                    let inside = false;
                    const n = polygon.length;
                    for (let i = 0, j = n - 1; i < n; j = i++) {
                        const xi = polygon[i][0], yi = polygon[i][1];
                        const xj = polygon[j][0], yj = polygon[j][1];
                        const intersect = ((yi > y) !== (yj > y)) && (x < (xi - xj) * (y - yi) / (yj - yi) + xi);
                        if (intersect) inside = !inside;
                    }
                    return inside;
                }

                updateCellInfo(cell) {
                    const { id, row, col, originalCoordinates, layer } = cell;
                    const coordText = originalCoordinates.map((coord, index) => {
                        const labels = ['å·¦ä¸‹è§’', 'å·¦ä¸Šè§’', 'å³ä¸Šè§’', 'å³ä¸‹è§’'];
                        const rounded = [Math.round(coord[0]), Math.round(coord[1])];
                        return `${labels[index]}: (${rounded[0]}, ${rounded[1]})`;
                    }).join('<br>');

                    const layerDisplay = layer + 1;
                    const angleInfo = this.mapAngle > 0 ? `<br><strong>å€¾æ–œè§’åº¦:</strong> ${this.mapAngle}Â°` : '';

                    // èµ„æºæ˜¾ç¤º â€”â€” æ˜¾ç¤ºä¸º "name: æ•°é‡"ï¼Œæ¯æ¡å•ç‹¬ä¸€è¡Œï¼Œåˆå¹¶ç›¸åŒ id çš„æ•°é‡
                    let resHtml = '';
                    if (cell.resources && cell.resources.length > 0) {
                        // åˆå¹¶ç›¸åŒ id çš„æ•°é‡
                        const counts = {};
                        for (const r of cell.resources) {
                            const idStr = String(r.id);
                            const qty = (r.qty != null) ? Number(r.qty) : ((r.quantity != null) ? Number(r.quantity) : 1);
                            counts[idStr] = (counts[idStr] || 0) + (isNaN(qty) ? 1 : qty);
                        }

                        const items = Object.entries(counts).map(([itemId, totalQty]) => {
                            const found = (this.allItems || []).find(a => String(a.id) === String(itemId));
                            const name = found ? found.name : itemId;
                            return `${name}: ${totalQty}`;
                        });

                        resHtml = `<br><strong>å·²åˆ†é…é¡¹:</strong><br>${items.join('<br>')}`;
                    }

                    document.getElementById('cellInfo').innerHTML = `
					<strong>æ ¼å­ #${id}</strong><br>
					ä½ç½®: ç¬¬${row + 1}è¡Œ, ç¬¬${col + 1}åˆ—<br>
					åœˆå±‚: ç¬¬${layerDisplay}åœˆ${angleInfo}<br>
					<strong>åæ ‡ç‚¹:</strong><br>
					${coordText}
					${resHtml}
				`;

                    // æ›´æ–°æ ¼å­å†…è”ç›Ÿèµ„æºåæ ‡æ˜¾ç¤º
                    this.updateCellResourceCoords(cell);
                }

                // æ›´æ–°æ ¼å­å†…è”ç›Ÿèµ„æºåæ ‡æ˜¾ç¤º
                updateCellResourceCoords(cell) {
                    const resourceCoordsDiv = document.getElementById('cellResourceCoords');
                    const resourceCoordsList = document.getElementById('resourceCoordsList');

                    if (cell.allianceResources && cell.allianceResources.length > 0) {
                        let coordsHtml = '';

                        // èµ„æºåç§°æ˜ å°„
                        const resourceNames = {
                            5001: 'è”ç›Ÿå†œåœº',
                            5002: 'è”ç›Ÿä¼æœ¨å‚',
                            5003: 'è”ç›Ÿç…¤çŸ¿å‚',
                            5004: 'è”ç›Ÿé“çŸ¿å‚'
                        };

                        // æŒ‰èµ„æºç±»å‹åˆ†ç»„æ˜¾ç¤ºåæ ‡
                        for (const resource of cell.allianceResources) {
                            const resourceName = resourceNames[resource.id] || `èµ„æº${resource.id}`;
                            coordsHtml += `<strong style="color: #333;">${resourceName}ï¼š</strong><br>`;

                            // æ˜¾ç¤ºæ¯ä¸ªåæ ‡ç‚¹
                            for (const coord of resource.coordinates) {
                                coordsHtml += `${coord.x};${coord.y}<br>`;
                            }

                            // æ·»åŠ ç©ºè¡Œåˆ†éš”ä¸åŒèµ„æºç±»å‹
                            coordsHtml += '<br>';
                        }

                        resourceCoordsList.innerHTML = coordsHtml.trim();
                        resourceCoordsDiv.style.display = 'block';
                    } else {
                        resourceCoordsDiv.style.display = 'none';
                    }
                }


                handleMouseDown(event) {
                    if (event.button === 2) {
                        this.isDragging = true;
                        this.dragStartX = event.clientX;
                        this.dragStartY = event.clientY;
                        this.canvas.style.cursor = 'grabbing';
                        event.preventDefault();
                    }
                }

                handleMouseMove(event) {
                    if (this.isDragging) {
                        const deltaX = event.clientX - this.dragStartX;
                        const deltaY = event.clientY - this.dragStartY;
                        // mapOffset in CSS px
                        this.mapOffsetX += deltaX;
                        this.mapOffsetY -= deltaY;
                        this.dragStartX = event.clientX;
                        this.dragStartY = event.clientY;
                        this.drawMap();
                        event.preventDefault();
                    } else {
                        this.handleCanvasHover(event);
                    }
                }

                handleMouseUp(event) {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.canvas.style.cursor = 'crosshair';
                    }
                }

                // é¼ æ ‡ç¦»å¼€ç”»å¸ƒå¤„ç†
                handleMouseLeave(event) {
                    this.hoveredCell = null;
                    this.checkAnimationLoop();
                    this.canvas.style.cursor = 'crosshair';
                }

                // å¡«å……åœˆå±‚é€‰æ‹©æ¡†
                updateLayerSelect() {
                    const select = document.getElementById('layerSelect');
                    select.innerHTML = '';
                    const layers = this.maxLayers || Math.ceil(Math.min(this.rows || 0, this.cols || 0) / 2);
                    for (let i = 0; i < layers; i++) {
                        const opt = document.createElement('option');
                        opt.value = String(i); // å­˜å‚¨ä¸ºé›¶åŸºç´¢å¼•
                        opt.text = `ç¬¬ ${i + 1} åœˆ`;
                        select.appendChild(opt);
                    }
                }

                updateLayerSelectSelection() {
                    // no-op for now; kept for compatibility
                }

                applyLayerHighlight() {
                    const sel = document.getElementById('layerSelect');
                    const selected = Array.from(sel.selectedOptions).map(o => Number(o.value));
                    this.highlightedLayers.clear();
                    for (const s of selected) this.highlightedLayers.add(s);
                    this.drawMap();
                }

                clearLayerHighlight() {
                    this.highlightedLayers.clear();
                    const sel = document.getElementById('layerSelect');
                    for (const o of Array.from(sel.options)) o.selected = false;
                    this.drawMap();
                }
                // apply selected items (from monster/resource select) to the currently selected cell
                applyItemsToSelectedCell(type) {
                    if (!this.selectedCell) {
                        alert('è¯·å…ˆåœ¨ç”»å¸ƒä¸Šé€‰æ‹©ä¸€ä¸ªæ ¼å­å†ä½¿ç”¨æ­¤åŠŸèƒ½ã€‚');
                        return;
                    }
                    const select = (type === 1) ? document.getElementById('monsterSelect') : document.getElementById('resourceSelect');
                    const qtyInput = (type === 1) ? document.getElementById('monsterQuantity') : document.getElementById('resourceQuantity');
                    const selectedOpts = Array.from(select.selectedOptions || []);
                    if (selectedOpts.length === 0) {
                        alert('è¯·å…ˆåœ¨åˆ—è¡¨ä¸­é€‰æ‹©ä¸€ä¸ªæˆ–å¤šä¸ªé¡¹ã€‚');
                        return;
                    }

                    // for each selected option, get id and quantity (prefer option.dataset.qty; fallback to qtyInput)
                    for (const opt of selectedOpts) {
                        const idStr = opt.value;
                        let qty = null;
                        // prefer dataset qty (set by setItemQuantity), else use qtyInput.value, else default 1
                        if (opt.dataset && opt.dataset.qty != null && opt.dataset.qty !== '') {
                            qty = parseInt(opt.dataset.qty);
                        } else {
                            qty = parseInt(qtyInput.value);
                        }
                        if (isNaN(qty)) qty = 0; // å…è®¸è´Ÿæ•°ï¼Œç”¨äºç§»é™¤èµ„æº

                        // merge into selectedCell.resources:
                        // if same type+id exists, increase qty (negative numbers will reduce)
                        const existing = this.selectedCell.resources.find(r => String(r.type) === String(type) && String(r.id) === String(idStr));
                        if (existing) {
                            existing.qty = (Number(existing.qty) || 0) + qty;
                        } else if (qty > 0) {
                            // åªæœ‰æ­£æ•°æ‰èƒ½åˆ›å»ºæ–°çš„èµ„æºé¡¹
                            this.selectedCell.resources.push({ type: type, id: idStr, qty: qty });
                        } else if (qty < 0) {
                            // å¦‚æœè¯•å›¾æ·»åŠ è´Ÿæ•°ä½†èµ„æºä¸å­˜åœ¨ï¼Œç»™å‡ºæç¤º
                            alert(`æ— æ³•ç§»é™¤ä¸å­˜åœ¨çš„èµ„æºï¼š${idStr}ï¼Œå½“å‰æ ¼å­ä¸­æ²¡æœ‰è¯¥èµ„æºã€‚`);
                        }
                    }

                    // æ¸…ç†æ•°é‡ä¸º0æˆ–è´Ÿæ•°çš„èµ„æºé¡¹
                    this.selectedCell.resources = this.selectedCell.resources.filter(r => r.qty > 0);

                    // å¯åŠ¨å•ä¸ªæ ¼å­èµ„æºåˆ†é…åŠ¨ç”»
                    this.startSingleCellResourceAnimation(this.selectedCell, () => {
                        this.updateCellInfo(this.selectedCell);
                        this.drawMap();

                        // æ˜¾ç¤ºç®€å•æˆåŠŸæç¤º
                        this.showAnimatedNotification('èµ„æºå·²æˆåŠŸåˆ†é…åˆ°é€‰å®šæ ¼å­', 'success', 2500);
                    });
                }

                // å°†é€‰ä¸­çš„æ€ªç‰©/èµ„æºæŒ‰å„è‡ªçš„ qty æ·»åŠ åˆ°è¢«é€‰åœˆå±‚çš„æ ¼å­ä¸Š
                applyItemsToSelectedLayers(type) {
                    // selected layers
                    const layerSel = document.getElementById('layerSelect');
                    const selectedLayers = Array.from(layerSel.selectedOptions).map(o => Number(o.value));
                    if (selectedLayers.length === 0) {
                        alert('è¯·å…ˆé€‰æ‹©è‡³å°‘ä¸€ä¸ªåœˆå±‚ã€‚');
                        return;
                    }

                    const listSel = (type === 1) ? document.getElementById('monsterSelect') : document.getElementById('resourceSelect');
                    const arr = (type === 1) ? this.monsters : this.resources;
                    const selectedOpts = Array.from(listSel.selectedOptions || []);
                    if (selectedOpts.length === 0) {
                        alert('è¯·å…ˆåœ¨æ€ªç‰©/èµ„æºåˆ—è¡¨ä¸­é€‰æ‹©è¦æ·»åŠ çš„é¡¹ï¼ˆå¯å¤šé€‰ï¼‰ã€‚');
                        return;
                    }

                    // for each selected item, get qty from data or underlying array
                    const itemsToApplyAll = selectedOpts.map(opt => {
                        const idStr = String(opt.value);
                        const found = arr.find(a => String(a.id) === idStr);
                        const qtyRaw = (found && found.qty != null) ? Number(found.qty) : (Number(opt.dataset.qty) || 0);
                        const qty = isNaN(qtyRaw) ? 0 : qtyRaw;
                        return { id: idStr, qty: qty };
                    });

                    // æ”¯æŒè´Ÿæ•°ï¼šè´Ÿæ•°ç”¨äºç§»é™¤èµ„æºï¼Œæ­£æ•°ç”¨äºæ·»åŠ èµ„æº
                    // åªè·³è¿‡å®Œå…¨æ— æ•ˆï¼ˆNaNï¼‰çš„é¡¹
                    const itemsToApply = itemsToApplyAll.filter(it => !isNaN(it.qty));
                    const invalidItems = itemsToApplyAll.length - itemsToApply.length;

                    if (itemsToApply.length === 0) {
                        // All selected items have invalid quantities
                        alert('é€‰ä¸­çš„é¡¹ä¸­æ‰€æœ‰æ•°é‡å‡æ— æ•ˆï¼Œè¯·è¾“å…¥æœ‰æ•ˆçš„æ•´æ•°æ•°é‡ã€‚');
                        return;
                    }

                    // find all cells in selected layers
                    const targetCells = this.cells.filter(c => selectedLayers.includes(c.layer));
                    if (targetCells.length === 0) {
                        alert('é€‰ä¸­çš„åœˆå±‚æ²¡æœ‰ä»»ä½•æ ¼å­ã€‚');
                        return;
                    }

                    // å¤„ç†æ¯ä¸ªæ ¼å­çš„èµ„æºæ·»åŠ /ç§»é™¤
                    for (const cell of targetCells) {
                        for (const it of itemsToApply) {
                            // æŸ¥æ‰¾æ˜¯å¦å·²å­˜åœ¨ç›¸åŒç±»å‹çš„èµ„æº
                            const existingIndex = cell.resources.findIndex(r =>
                                String(r.type) === String(type) && String(r.id) === String(it.id)
                            );

                            if (existingIndex >= 0) {
                                // å¦‚æœå·²å­˜åœ¨ï¼Œå¢åŠ æ•°é‡ï¼ˆè´Ÿæ•°ä¼šå‡å°‘ï¼‰
                                cell.resources[existingIndex].qty += it.qty;
                            } else if (it.qty > 0) {
                                // å¦‚æœä¸å­˜åœ¨ä¸”æ•°é‡ä¸ºæ­£æ•°ï¼Œåˆ™æ·»åŠ æ–°èµ„æº
                                cell.resources.push({ type, id: it.id, qty: it.qty });
                            }
                            // å¦‚æœæ•°é‡ä¸ºè´Ÿæ•°ä¸”ä¸å­˜åœ¨ï¼Œä¸éœ€è¦æ·»åŠ ï¼ˆè´Ÿæ•°ä¸èƒ½ç”¨äºåˆ›å»ºæ–°èµ„æºï¼Œåªèƒ½ç”¨äºç§»é™¤ç°æœ‰èµ„æºï¼‰
                        }

                        // æ¸…ç†æ•°é‡ä¸º0æˆ–è´Ÿæ•°çš„èµ„æºé¡¹
                        cell.resources = cell.resources.filter(r => r.qty > 0);
                    }

                    // å¯åŠ¨èµ„æºåˆ†é…åŠ¨ç”»
                    this.startResourceAllocationAnimation(targetCells, itemsToApply, () => {
                        this.drawMap();

                        // æä¾›åŠ¨ç”»å®Œæˆæç¤º
                        const addedCount = itemsToApply.filter(it => it.qty > 0).length;
                        const removedCount = itemsToApply.filter(it => it.qty < 0).length;
                        let msg = `å¤„ç†å®Œæˆï¼šå…± ${itemsToApply.length} é¡¹å·²åº”ç”¨åˆ° ${targetCells.length} ä¸ªæ ¼å­ã€‚`;
                        if (addedCount > 0) {
                            msg += `\nå…¶ä¸­ ${addedCount} é¡¹ä¸ºæ·»åŠ ï¼ˆæ­£æ•°æ•°é‡ï¼‰ã€‚`;
                        }
                        if (removedCount > 0) {
                            msg += `\nå…¶ä¸­ ${removedCount} é¡¹ä¸ºç§»é™¤ï¼ˆè´Ÿæ•°æ•°é‡ï¼‰ã€‚`;
                        }
                        if (invalidItems > 0) {
                            msg += `\næœ‰ ${invalidItems} é¡¹å› æ•°é‡æ— æ•ˆè¢«è·³è¿‡ã€‚`;
                        }

                        // æ˜¾ç¤ºåŠ¨ç”»å®Œæˆæç¤º
                        this.showAnimatedNotification(msg, addedCount > 0 ? 'success' : 'info');
                    });
                }

                exportSeparatedData() {
                    // export monsters first then empty line then resources
                    // æ±‡æ€»ç›¸åŒæ ¼å­çš„æ•°æ®ï¼šcellId -> {type1: [items], type2: [items]}
                    const cellDataMap = new Map();

                    for (const c of this.cells) {
                        if (!c.resources || c.resources.length === 0) continue;

                        if (!cellDataMap.has(c.id)) {
                            cellDataMap.set(c.id, { monsters: [], resources: [] });
                        }

                        const cellData = cellDataMap.get(c.id);
                        for (const r of c.resources) {
                            if (r.type === 1) {
                                cellData.monsters.push({ id: r.id, qty: r.qty });
                            } else if (r.type === 2) {
                                cellData.resources.push({ id: r.id, qty: r.qty });
                            }
                        }
                    }

                    const lines = [];

                    // å¯¼å‡ºæ€ªç‰©æ•°æ®
                    for (const [cellId, data] of cellDataMap) {
                        if (data.monsters.length > 0) {
                            const monsterParts = data.monsters.map(m => `${m.id};${m.qty}`);
                            lines.push(`${cellId}:${monsterParts.join('|')}`);
                        }
                    }

                    // ç©ºè¡Œåˆ†éš”
                    lines.push('');

                    // å¯¼å‡ºèµ„æºæ•°æ®
                    for (const [cellId, data] of cellDataMap) {
                        if (data.resources.length > 0) {
                            const resourceParts = data.resources.map(r => `${r.id};${r.qty}`);
                            lines.push(`${cellId}:${resourceParts.join('|')}`);
                        }
                    }

                    const blob = new Blob([lines.join('\n')], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'export.txt';
                    a.click();
                    URL.revokeObjectURL(url);
                }

                printData() {
                    if (!this.cells || this.cells.length === 0) {
                        alert('æ²¡æœ‰å¯å¯¼å‡ºçš„æ ¼å­æ•°æ®ï¼Œè¯·å…ˆç”Ÿæˆåœ°å›¾ã€‚');
                        return;
                    }

                    // æ ¼å¼åŒ–æ•°æ®ï¼šæ ¼å­ç¼–å·:å·¦ä¸‹è§’X;å·¦ä¸‹è§’Y|å·¦ä¸Šè§’X;å·¦ä¸Šè§’Y|å³ä¸Šè§’X;å³ä¸Šè§’Y|å³ä¸‹è§’X;å³ä¸‹è§’Y
                    const dataLines = this.cells.map(cell => {
                        const coords = cell.coordinates;
                        if (!coords || coords.length < 4) return null;

                        // å·¦ä¸‹è§’: [0], å·¦ä¸Šè§’: [1], å³ä¸Šè§’: [2], å³ä¸‹è§’: [3]
                        const lowerLeft = `${coords[0][0]};${coords[0][1]}`;
                        const upperLeft = `${coords[1][0]};${coords[1][1]}`;
                        const upperRight = `${coords[2][0]};${coords[2][1]}`;
                        const lowerRight = `${coords[3][0]};${coords[3][1]}`;

                        return `${cell.id}:${lowerLeft}|${upperLeft}|${upperRight}|${lowerRight}`;
                    }).filter(line => line !== null);

                    if (dataLines.length === 0) {
                        alert('æ²¡æœ‰æœ‰æ•ˆçš„æ ¼å­åæ ‡æ•°æ®ã€‚');
                        return;
                    }

                    // åˆ›å»ºåæ ‡æ•°æ®å†…å®¹
                    const coordinateContent = dataLines.join('\n');

                    // æ”¶é›†è”ç›Ÿèµ„æºåæ ‡æ•°æ®ï¼ŒæŒ‰ç±»å‹åˆ†ç»„
                    const resourceGroups = {
                        'è”ç›Ÿå†œåœº': [],
                        'è”ç›Ÿä¼æœ¨å‚': [],
                        'è”ç›Ÿç…¤çŸ¿å‚': [],
                        'è”ç›Ÿé“çŸ¿å‚': []
                    };

                    for (const cell of this.cells) {
                        if (cell.allianceResources && cell.allianceResources.length > 0) {
                            for (const resource of cell.allianceResources) {
                                // èµ„æºåç§°æ˜ å°„
                                const resourceNames = {
                                    5001: 'è”ç›Ÿå†œåœº',
                                    5002: 'è”ç›Ÿä¼æœ¨å‚',
                                    5003: 'è”ç›Ÿç…¤çŸ¿å‚',
                                    5004: 'è”ç›Ÿé“çŸ¿å‚'
                                };
                                const resourceName = resourceNames[resource.id] || `èµ„æº${resource.id}`;

                                // æ”¶é›†åæ ‡ç‚¹
                                for (const coord of resource.coordinates) {
                                    // æ ¼å¼ï¼š512;444
                                    resourceGroups[resourceName].push(`${coord.x};${coord.y}`);
                                }
                            }
                        }
                    }

                    // æ„å»ºæœ€ç»ˆæ–‡æœ¬å†…å®¹
                    let finalContent = coordinateContent;

                    // å¦‚æœæœ‰è”ç›Ÿèµ„æºåæ ‡æ•°æ®ï¼ŒæŒ‰ç±»å‹åˆ†ç»„è¿½åŠ åˆ°æ–‡ä»¶æœ«å°¾
                    const hasResources = Object.values(resourceGroups).some(group => group.length > 0);
                    if (hasResources) {
                        finalContent += '\n\nè”ç›Ÿèµ„æºåæ ‡æ•°æ®ï¼š\n';

                        // æŒ‰å›ºå®šé¡ºåºè¾“å‡ºèµ„æºç±»å‹
                        const resourceOrder = ['è”ç›Ÿå†œåœº', 'è”ç›Ÿä¼æœ¨å‚', 'è”ç›Ÿç…¤çŸ¿å‚', 'è”ç›Ÿé“çŸ¿å‚'];

                        for (const resourceName of resourceOrder) {
                            const coordinates = resourceGroups[resourceName];
                            if (coordinates.length > 0) {
                                finalContent += `\n${resourceName}ï¼š\n`;
                                finalContent += coordinates.join('\n');
                            }
                        }
                    }

                    // åˆ›å»ºBlobå¯¹è±¡å¹¶ä¸‹è½½ä¸ºtxtæ–‡ä»¶
                    const blob = new Blob([finalContent], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `map_coordinates_${new Date().getTime()}.txt`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);

                    let message = `å·²å¯¼å‡º ${dataLines.length} ä¸ªæ ¼å­çš„åæ ‡æ•°æ®`;
                    if (allianceResourceLines.length > 0) {
                        message += `å’Œ ${allianceResourceLines.length} ä¸ªè”ç›Ÿèµ„æºåæ ‡ç‚¹`;
                    }
                    message += `åˆ°æ–‡ä»¶ï¼šmap_coordinates_${new Date().getTime()}.txt`;
                    alert(message);
                }

                // === è”ç›Ÿèµ„æºç›¸å…³æ–¹æ³• ===

                // åˆ‡æ¢å‰”é™¤æ¨¡å¼
                toggleExcludeMode() {
                    this.excludeMode = !this.excludeMode;
                    const btn = document.getElementById('excludeBtn');
                    if (this.excludeMode) {
                        btn.style.background = '#ff5722';
                        btn.textContent = 'å‰”é™¤æ¨¡å¼å·²æ¿€æ´»ï¼ˆå†æ¬¡ç‚¹å‡»å…³é—­ï¼‰';
                        this.canvas.style.cursor = 'crosshair';
                    } else {
                        btn.style.background = '#ffc107';
                        btn.textContent = 'ç‚¹å‡»å‰”é™¤æ ¼å­ï¼ˆæ¿€æ´»åå•å‡»æ ¼å­æ ‡é»„ï¼‰';
                        this.canvas.style.cursor = 'default';
                    }
                }

                // æ¸…é™¤æ‰€æœ‰å‰”é™¤çš„æ ¼å­
                clearExcludedCells() {
                    this.excludedCells.clear();
                    this.drawMap();
                }

                // ç”Ÿæˆè”ç›Ÿèµ„æº
                generateAllianceResources() {
                    // è·å–è¾“å…¥çš„æ•°é‡ï¼ˆæ¯ä¸ªæ ¼å­çš„èµ„æºæ•°é‡ï¼‰
                    const farmCount = parseInt(document.getElementById('allianceFarm').value) || 0;
                    const woodCount = parseInt(document.getElementById('allianceWood').value) || 0;
                    const mineCount = parseInt(document.getElementById('allianceMine').value) || 0;
                    const ironCount = parseInt(document.getElementById('allianceIron').value) || 0;
                    const radius = parseInt(document.getElementById('resourceRadius').value) || 0;

                    if (farmCount === 0 && woodCount === 0 && mineCount === 0 && ironCount === 0) {
                        alert('è¯·è‡³å°‘è¾“å…¥ä¸€ç§èµ„æºçš„æ•°é‡ï¼');
                        return;
                    }

                    // æ¸…é™¤ç°æœ‰çš„è”ç›Ÿèµ„æº
                    this.clearAllianceResources(false); // ä¸æ˜¾ç¤ºæç¤ºï¼Œå› ä¸ºæˆ‘ä»¬è¦æ˜¾ç¤ºæ–°çš„ç»Ÿè®¡

                    // è·å–å¯ç”¨çš„æ ¼å­ï¼ˆæœªè¢«å‰”é™¤çš„ï¼‰
                    const availableCells = this.cells.filter(cell => !this.excludedCells.has(cell.id));

                    if (availableCells.length === 0) {
                        alert('æ²¡æœ‰å¯ç”¨çš„æ ¼å­ç”Ÿæˆèµ„æºï¼è¯·å…ˆæ¸…é™¤å‰”é™¤æˆ–é€‰æ‹©å…¶ä»–æ ¼å­ã€‚');
                        return;
                    }

                    // å‡†å¤‡è¦åˆ†é…åˆ°æ¯ä¸ªæ ¼å­çš„èµ„æºåˆ—è¡¨
                    const resourcesPerCell = [];
                    if (farmCount > 0) resourcesPerCell.push({ id: 5001, name: 'è”ç›Ÿå†œåœº', count: farmCount });
                    if (woodCount > 0) resourcesPerCell.push({ id: 5002, name: 'è”ç›Ÿä¼æœ¨å‚', count: woodCount });
                    if (mineCount > 0) resourcesPerCell.push({ id: 5003, name: 'è”ç›Ÿç…¤çŸ¿å‚', count: mineCount });
                    if (ironCount > 0) resourcesPerCell.push({ id: 5004, name: 'è”ç›Ÿé“çŸ¿å‚', count: ironCount });

                    // è®°å½•åˆ†é…ç»Ÿè®¡
                    const stats = {
                        totalCells: availableCells.length,
                        resourcesPerCell: resourcesPerCell.reduce((sum, r) => sum + r.count, 0),
                        totalResources: availableCells.length * resourcesPerCell.reduce((sum, r) => sum + r.count, 0),
                        generated: 0
                    };

                    // ä¸ºæ¯ä¸ªå¯ç”¨æ ¼å­ç”Ÿæˆèµ„æºçš„å…·ä½“åæ ‡ç‚¹
                    for (const cell of availableCells) {
                        // è·å–æ ¼å­çš„è¾¹ç•Œåæ ‡
                        const bounds = this.getCellBounds(cell);
                        if (!bounds) continue;

                        // ä¸ºæ¯ç§èµ„æºç±»å‹ç”ŸæˆæŒ‡å®šæ•°é‡çš„éšæœºåæ ‡ç‚¹
                        for (const resource of resourcesPerCell) {
                            const coordinates = [];

                            // ç”ŸæˆæŒ‡å®šæ•°é‡çš„éšæœºåæ ‡ç‚¹
                            for (let i = 0; i < resource.count; i++) {
                                // åœ¨æ ¼å­è¾¹ç•Œå†…ç”Ÿæˆéšæœºåæ ‡
                                let attempts = 0;
                                let validCoordinate = null;

                                // æœ€å¤šå°è¯•100æ¬¡æ‰¾åˆ°æœ‰æ•ˆçš„åæ ‡ï¼ˆè€ƒè™‘åŠå¾„é™åˆ¶ï¼‰
                                while (attempts < 100 && !validCoordinate) {
                                    const x = Math.floor(Math.random() * (bounds.maxX - bounds.minX + 1)) + bounds.minX;
                                    const y = Math.floor(Math.random() * (bounds.maxY - bounds.minY + 1)) + bounds.minY;

                                    // æ£€æŸ¥åŠå¾„é™åˆ¶
                                    if (this.isCoordinateValidForResource(x, y, resource.id, radius)) {
                                        validCoordinate = { x, y };
                                    }
                                    attempts++;
                                }

                                if (validCoordinate) {
                                    coordinates.push(validCoordinate);
                                    stats.generated++;
                                }
                            }

                            // å°†åæ ‡æ•°æ®å­˜å‚¨åˆ°æ ¼å­ä¸­
                            if (coordinates.length > 0) {
                                if (!cell.allianceResources) {
                                    cell.allianceResources = [];
                                }
                                cell.allianceResources.push({
                                    id: resource.id,
                                    name: resource.name,
                                    type: 3,
                                    coordinates: coordinates
                                });
                            }
                        }
                    }

                    // æ›´æ–°æ˜¾ç¤ºå’Œç»Ÿè®¡
                    this.drawMap();
                    this.showResourceStats(stats);
                }

                // è·å–æ ¼å­çš„è¾¹ç•Œåæ ‡
                getCellBounds(cell) {
                    if (!cell.coordinates || cell.coordinates.length < 4) return null;

                    const xs = cell.coordinates.map(coord => coord[0]);
                    const ys = cell.coordinates.map(coord => coord[1]);

                    return {
                        minX: Math.min(...xs),
                        maxX: Math.max(...xs),
                        minY: Math.min(...ys),
                        maxY: Math.max(...ys)
                    };
                }

                // æ£€æŸ¥åæ ‡æ˜¯å¦å¯ä»¥æ”¾ç½®èµ„æºï¼ˆè€ƒè™‘åŠå¾„é™åˆ¶ï¼‰
                isCoordinateValidForResource(x, y, resourceId, radius) {
                    if (radius === 0) return true;

                    // æ£€æŸ¥æ‰€æœ‰æ ¼å­çš„è”ç›Ÿèµ„æºåæ ‡
                    for (const cell of this.cells) {
                        if (!cell.allianceResources) continue;

                        for (const resource of cell.allianceResources) {
                            // ç§»é™¤è¿™è¡Œï¼šæ£€æŸ¥æ‰€æœ‰èµ„æºï¼Œä¸ä»…ä»…æ˜¯ç›¸åŒç±»å‹
                            // if (resource.id !== resourceId) continue;

                            for (const coord of resource.coordinates) {
                                // è®¡ç®—ä¸¤ä¸ªåæ ‡ç‚¹ä¹‹é—´çš„è·ç¦»
                                const distance = Math.sqrt(
                                    Math.pow(x - coord.x, 2) + Math.pow(y - coord.y, 2)
                                );

                                // å¦‚æœè·ç¦»å°äºåŠå¾„é™åˆ¶ï¼Œä¸èƒ½æ”¾ç½®
                                if (distance < radius) {
                                    return false;
                                }
                            }
                        }
                    }

                    return true;
                }

                // å°†èµ„æºåˆ†é…åˆ°æ ¼å­
                allocateResourceToCells(resource, availableCells, radius) {
                    // å¤åˆ¶å¯ç”¨æ ¼å­åˆ—è¡¨ï¼Œé¿å…ä¿®æ”¹åŸæ•°ç»„
                    const cells = [...availableCells];
                    let allocated = 0;

                    // éšæœºæ‰“ä¹±æ ¼å­é¡ºåºï¼Œä½¿åˆ†é…æ›´åŠ éšæœº
                    for (let i = cells.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [cells[i], cells[j]] = [cells[j], cells[i]];
                    }

                    // ä¸ºæ¯ä¸ªèµ„æºå•ä½åˆ†é…æ ¼å­
                    for (let i = 0; i < resource.count && cells.length > 0; i++) {
                        // æ‰¾åˆ°ä¸€ä¸ªç¬¦åˆåŠå¾„é™åˆ¶çš„æ ¼å­
                        let foundCell = null;
                        for (let j = 0; j < cells.length; j++) {
                            const cell = cells[j];
                            if (this.isCellValidForResource(cell, resource.id, radius)) {
                                foundCell = cell;
                                cells.splice(j, 1); // ä»å¯ç”¨åˆ—è¡¨ä¸­ç§»é™¤
                                break;
                            }
                        }

                        if (foundCell) {
                            // æ·»åŠ èµ„æºåˆ°æ ¼å­
                            if (!foundCell.resources) {
                                foundCell.resources = [];
                            }
                            foundCell.resources.push({
                                id: resource.id,
                                name: resource.name,
                                type: 3,
                                qty: 1
                            });
                            allocated++;
                        } else {
                            // æ²¡æœ‰æ‰¾åˆ°ç¬¦åˆçš„æ ¼å­ï¼Œåœæ­¢åˆ†é…
                            break;
                        }
                    }

                    return allocated;
                }

                // æ£€æŸ¥æ ¼å­æ˜¯å¦å¯ä»¥æ”¾ç½®èµ„æºï¼ˆè€ƒè™‘åŠå¾„é™åˆ¶ï¼‰
                isCellValidForResource(cell, resourceId, radius) {
                    if (radius === 0) return true;

                    // è·å–å½“å‰æ ¼å­çš„ä¸­å¿ƒç‚¹åæ ‡
                    const cellCenter = this.getCellCenter(cell);

                    // æ£€æŸ¥åŠå¾„å†…çš„å…¶ä»–æ ¼å­æ˜¯å¦æœ‰ç›¸åŒç±»å‹çš„èµ„æº
                    for (const otherCell of this.cells) {
                        if (otherCell.id === cell.id) continue;

                        // æ£€æŸ¥å…¶ä»–æ ¼å­æ˜¯å¦æœ‰ç›¸åŒç±»å‹çš„èµ„æº
                        if (otherCell.resources && otherCell.resources.some(r => r.id === resourceId)) {
                            // è·å–å…¶ä»–æ ¼å­çš„ä¸­å¿ƒç‚¹åæ ‡
                            const otherCenter = this.getCellCenter(otherCell);

                            // è®¡ç®—ä¸¤ä¸ªæ ¼å­ä¸­å¿ƒç‚¹ä¹‹é—´çš„åƒç´ è·ç¦»
                            const distance = Math.sqrt(
                                Math.pow(cellCenter.x - otherCenter.x, 2) +
                                Math.pow(cellCenter.y - otherCenter.y, 2)
                            );

                            // å¦‚æœè·ç¦»å°äºåŠå¾„é™åˆ¶ï¼Œä¸èƒ½æ”¾ç½®
                            if (distance < radius) {
                                return false;
                            }
                        }
                    }

                    return true;
                }

                // è·å–æ ¼å­çš„ä¸­å¿ƒç‚¹åæ ‡
                getCellCenter(cell) {
                    // è®¡ç®—æ ¼å­å¤šè¾¹å½¢çš„ä¸­å¿ƒç‚¹
                    let sumX = 0, sumY = 0;
                    for (const point of cell.coordinates) {
                        sumX += point[0];
                        sumY += point[1];
                    }
                    return {
                        x: sumX / cell.coordinates.length,
                        y: sumY / cell.coordinates.length
                    };
                }

                // è·å–æ ¼å­åœ¨åœˆå±‚ä¸­çš„ä½ç½®
                getCellPositionInLayer(cell) {
                    const layerCells = this.cells.filter(c => c.layer === cell.layer);
                    for (let i = 0; i < layerCells.length; i++) {
                        if (layerCells[i].id === cell.id) {
                            return i;
                        }
                    }
                    return -1;
                }

                // æ¸…é™¤è”ç›Ÿèµ„æº
                clearAllianceResources(showAlert = true) {
                    let clearedCount = 0;
                    for (const cell of this.cells) {
                        // æ¸…é™¤æ—§çš„èµ„æºæ•°æ®ç»“æ„
                        if (cell.resources) {
                            const allianceResources = cell.resources.filter(r => r.type === 3);
                            clearedCount += allianceResources.length;
                            cell.resources = cell.resources.filter(r => r.type !== 3);
                        }
                        // æ¸…é™¤æ–°çš„åæ ‡æ•°æ®ç»“æ„
                        if (cell.allianceResources) {
                            for (const resource of cell.allianceResources) {
                                clearedCount += resource.coordinates.length;
                            }
                            delete cell.allianceResources;
                        }
                    }

                    this.drawMap();
                    document.getElementById('resourceStats').style.display = 'none';

                    if (showAlert && clearedCount > 0) {
                        alert(`å·²æ¸…é™¤ ${clearedCount} ä¸ªè”ç›Ÿèµ„æºåæ ‡ç‚¹ï¼`);
                    }
                }

                // æ˜¾ç¤ºèµ„æºç»Ÿè®¡
                showResourceStats(stats) {
                    const statsDiv = document.getElementById('resourceStats');
                    const contentDiv = document.getElementById('statsContent');

                    let html = `<strong>è”ç›Ÿèµ„æºç”Ÿæˆç»Ÿè®¡ï¼š</strong><br>`;
                    html += `å¯ç”¨æ ¼å­æ•°ï¼š${stats.totalCells} ä¸ª<br>`;
                    html += `æ¯ä¸ªæ ¼å­èµ„æºç§ç±»ï¼š${stats.resourcesPerCell} ç§<br>`;
                    html += `åº”ç”Ÿæˆèµ„æºæ€»æ•°ï¼š${stats.totalResources} ä¸ª<br>`;
                    html += `å®é™…ç”Ÿæˆèµ„æºæ•°ï¼š${stats.generated} ä¸ª<br>`;

                    if (stats.generated < stats.totalResources) {
                        const notGenerated = stats.totalResources - stats.generated;
                        html += `<br><strong style="color: #ff5722;">âš ï¸ å› åŠå¾„é™åˆ¶æœªèƒ½ç”Ÿæˆï¼š${notGenerated} ä¸ªèµ„æº</strong><br>`;
                        html += `<small style="color: #666;">æç¤ºï¼šæ‚¨å¯ä»¥å°è¯•å‡å°åŠå¾„é™åˆ¶æˆ–æ¸…é™¤ä¸€äº›å‰”é™¤çš„æ ¼å­</small>`;
                    } else {
                        html += `<br><strong style="color: #4caf50;">âœ… æ‰€æœ‰èµ„æºå·²æˆåŠŸç”Ÿæˆï¼</strong>`;
                    }

                    contentDiv.innerHTML = html;
                    statsDiv.style.display = 'block';
                }

                // === åæ ‡æŸ¥æ‰¾åŠŸèƒ½ ===

                // æ ¹æ®åæ ‡æŸ¥æ‰¾æ ¼å­å¹¶é«˜äº®æ˜¾ç¤º
                findCellByCoordinate() {
                    const input = document.getElementById('coordinateInput').value.trim();
                    const resultDiv = document.getElementById('coordinateSearchResult');

                    if (!input) {
                        resultDiv.innerHTML = '<span style="color: #ff5722;">è¯·è¾“å…¥åæ ‡ï¼Œæ ¼å¼ï¼šX;Y</span>';
                        return;
                    }

                    // è§£æåæ ‡ï¼Œæ”¯æŒåˆ†å·æˆ–ç©ºæ ¼åˆ†éš”
                    const coords = input.split(/[;,]\s*/);
                    if (coords.length !== 2) {
                        resultDiv.innerHTML = '<span style="color: #ff5722;">åæ ‡æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨æ ¼å¼ï¼šX;Y æˆ– X,Y</span>';
                        return;
                    }

                    const x = parseFloat(coords[0]);
                    const y = parseFloat(coords[1]);

                    if (isNaN(x) || isNaN(y)) {
                        resultDiv.innerHTML = '<span style="color: #ff5722;">åæ ‡å€¼å¿…é¡»æ˜¯æ•°å­—</span>';
                        return;
                    }

                    // æŸ¥æ‰¾åŒ…å«è¯¥åæ ‡çš„æ ¼å­
                    const foundCell = this.cells.find(cell => this.isPointInPolygon(x, y, cell.coordinates));

                    if (foundCell) {
                        // è®¾ç½®æŸ¥æ‰¾é«˜äº®æ ¼å­ï¼ˆä¸æ”¹å˜æ‰‹åŠ¨é€‰æ‹©ï¼‰
                        this.searchHighlightedCell = foundCell;
                        this.updateCellInfo(foundCell);
                        this.drawMap();

                        // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                        resultDiv.innerHTML = `<span style="color: #007bff;">âœ… æ‰¾åˆ°åæ ‡ (${x}, ${y}) æ‰€åœ¨çš„æ ¼å­ #${foundCell.id} - ä½ç½®ï¼šç¬¬${foundCell.row + 1}è¡Œ, ç¬¬${foundCell.col + 1}åˆ—ï¼Œç¬¬${foundCell.layer + 1}åœˆ</span>`;
                    } else {
                        // æ¸…é™¤æŸ¥æ‰¾é«˜äº®
                        this.searchHighlightedCell = null;
                        this.drawMap();

                        resultDiv.innerHTML = `<span style="color: #ff5722;">âŒ æœªæ‰¾åˆ°åæ ‡ (${x}, ${y}) æ‰€åœ¨çš„æ ¼å­ï¼Œè¯·æ£€æŸ¥åæ ‡æ˜¯å¦åœ¨åœ°å›¾èŒƒå›´å†…</span>`;
                    }
                }

                // æ¸…é™¤åæ ‡æŸ¥æ‰¾ç»“æœå’Œé«˜äº®
                clearCoordinateSearch() {
                    // æ¸…é™¤æŸ¥æ‰¾é«˜äº®çš„æ ¼å­
                    this.searchHighlightedCell = null;

                    // æ¸…ç©ºè¾“å…¥æ¡†
                    document.getElementById('coordinateInput').value = '';

                    // æ¸…é™¤ç»“æœæ˜¾ç¤º
                    document.getElementById('coordinateSearchResult').innerHTML = '';

                    // é‡æ–°ç»˜åˆ¶åœ°å›¾ä»¥æ¸…é™¤é«˜äº®æ•ˆæœ
                    this.drawMap();
                }

                // === åŠ¨ç”»åŠŸèƒ½ ===

                // å¯åŠ¨åŠ¨ç”»å¾ªç¯
                startAnimationLoop() {
                    if (!this.animationFrame) {
                        this.animationFrame = requestAnimationFrame(() => this.animate());
                    }
                }

                // æ£€æŸ¥æ˜¯å¦éœ€è¦ç»§ç»­åŠ¨ç”»å¾ªç¯
                checkAnimationLoop() {
                    const needsAnimation = this.hoveredCell ||
                        (this.selectedCell && this.selectedCell.animationStartTime) ||
                        (this.searchHighlightedCell && this.searchHighlightedCell.animationStartTime);

                    if (!needsAnimation && this.animationFrame) {
                        cancelAnimationFrame(this.animationFrame);
                        this.animationFrame = null;
                    }
                }

                // åŠ¨ç”»å¾ªç¯
                animate() {
                    this.drawMap();

                    // æ£€æŸ¥æ˜¯å¦è¿˜éœ€è¦ç»§ç»­åŠ¨ç”»
                    this.checkAnimationLoop();

                    if (this.animationFrame) {
                        this.animationFrame = requestAnimationFrame(() => this.animate());
                    }
                }

                // === åŠ è½½åŠ¨ç”»åŠŸèƒ½ ===

                // æ˜¾ç¤ºåŠ è½½æŒ‡ç¤ºå™¨
                showLoadingIndicator() {
                    const indicator = document.getElementById('loadingIndicator');
                    indicator.style.display = 'block';
                    indicator.style.animation = 'fadeIn 0.3s ease-out';
                    this.updateLoadingProgress(0);
                }

                // éšè—åŠ è½½æŒ‡ç¤ºå™¨
                hideLoadingIndicator() {
                    const indicator = document.getElementById('loadingIndicator');
                    indicator.style.animation = 'fadeIn 0.3s ease-out reverse';
                    setTimeout(() => {
                        indicator.style.display = 'none';
                    }, 300);
                }

                // èµ„æºåˆ†é…åŠ¨ç”»
                startResourceAllocationAnimation(targetCells, itemsToApply, callback) {
                    const animationDuration = 1500; // 1.5ç§’åŠ¨ç”»æ—¶é—´
                    const startTime = Date.now();

                    // ä¸ºæ¯ä¸ªç›®æ ‡æ ¼å­æ·»åŠ åŠ¨ç”»çŠ¶æ€
                    targetCells.forEach(cell => {
                        cell.isAnimating = true;
                        cell.animationStart = startTime;
                        cell.animationItems = itemsToApply;
                    });

                    const animate = () => {
                        const currentTime = Date.now();
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / animationDuration, 1);

                        // æ¸…é™¤ä¹‹å‰çš„åŠ¨ç”»æ ¼å­
                        this.cells.forEach(cell => {
                            delete cell.isAnimating;
                            delete cell.animationProgress;
                        });

                        // æ›´æ–°å½“å‰åŠ¨ç”»çŠ¶æ€
                        targetCells.forEach((cell, index) => {
                            const cellProgress = Math.min((elapsed - index * 50) / animationDuration, 1); // é”™å¼€åŠ¨ç”»æ—¶é—´
                            if (cellProgress > 0) {
                                cell.isAnimating = true;
                                cell.animationProgress = cellProgress;
                            }
                        });

                        this.drawMap();

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            // åŠ¨ç”»ç»“æŸï¼Œæ¸…ç†çŠ¶æ€
                            this.cells.forEach(cell => {
                                delete cell.isAnimating;
                                delete cell.animationProgress;
                                delete cell.animationStart;
                                delete cell.animationItems;
                            });

                            // æ‰§è¡Œå›è°ƒ
                            if (callback) callback();
                        }
                    };

                    animate();
                }

                // æ˜¾ç¤ºåŠ¨ç”»é€šçŸ¥
                showAnimatedNotification(message, type = 'info', duration = 4000) {
                    // åˆ›å»ºé€šçŸ¥å…ƒç´ 
                    const notification = document.createElement('div');
                    notification.className = `notification ${type}`;
                    notification.innerHTML = `
                        <div style="margin-bottom: 8px; font-size: 16px; font-weight: 600;">
                            ${type === 'success' ? 'âœ…' : type === 'warning' ? 'âš ï¸' : type === 'error' ? 'âŒ' : 'â„¹ï¸'}
                            ${type === 'success' ? 'æ“ä½œæˆåŠŸ' : type === 'warning' ? 'æ³¨æ„' : type === 'error' ? 'é”™è¯¯' : 'ä¿¡æ¯'}
                        </div>
                        <div style="font-size: 14px; line-height: 1.4;">${message.replace(/\n/g, '<br>')}</div>
                    `;

                    // æ·»åŠ åˆ°é¡µé¢
                    document.body.appendChild(notification);

                    // è‡ªåŠ¨éšè—
                    setTimeout(() => {
                        notification.classList.add('hiding');
                        setTimeout(() => {
                            if (notification.parentNode) {
                                notification.parentNode.removeChild(notification);
                            }
                        }, 300);
                    }, duration);
                }

                // å•ä¸ªæ ¼å­èµ„æºåˆ†é…åŠ¨ç”»
                startSingleCellResourceAnimation(cell, callback) {
                    const animationDuration = 800; // 0.8ç§’åŠ¨ç”»æ—¶é—´
                    const startTime = Date.now();

                    // ä¸ºæ ¼å­æ·»åŠ åŠ¨ç”»çŠ¶æ€
                    cell.isAnimating = true;
                    cell.animationStart = startTime;

                    const animate = () => {
                        const currentTime = Date.now();
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / animationDuration, 1);

                        // æ›´æ–°åŠ¨ç”»è¿›åº¦
                        cell.animationProgress = progress;

                        this.drawMap();

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            // åŠ¨ç”»ç»“æŸï¼Œæ¸…ç†çŠ¶æ€
                            delete cell.isAnimating;
                            delete cell.animationProgress;
                            delete cell.animationStart;

                            // æ‰§è¡Œå›è°ƒ
                            if (callback) callback();
                        }
                    };

                    animate();
                }

                // æ›´æ–°åŠ è½½è¿›åº¦
                updateLoadingProgress(progress) {
                    document.getElementById('loadingProgress').textContent = Math.round(progress);
                    document.getElementById('loadingBar').style.width = `${progress}%`;
                }

                // å¸¦è¿›åº¦çš„åœ°å›¾ç”Ÿæˆ
                async generateMapWithProgress() {
                    // æ¸…ç©ºç°æœ‰æ ¼å­
                    this.cells = [];
                    let cellId = 1;
                    const totalCells = Math.ceil(this.rows * this.cols);

                    const layers = Math.ceil(Math.min(this.rows, this.cols) / 2);

                    // æ¨¡æ‹Ÿåˆ†æ­¥éª¤ç”Ÿæˆï¼Œæ¯10msæ›´æ–°ä¸€æ¬¡è¿›åº¦
                    let currentProgress = 0;
                    const steps = totalCells;
                    const stepDelay = 5; // æ¯æ­¥5ms

                    for (let layer = 0; layer < layers; layer++) {
                        const topRow = this.rows - 1 - layer;
                        const bottomRow = layer;
                        const leftCol = layer;
                        const rightCol = this.cols - 1 - layer;

                        // æ¯ç”Ÿæˆä¸€ä¸ªæ ¼å­ï¼Œæ›´æ–°è¿›åº¦
                        const generateCell = (row, col, id) => {
                            return new Promise(resolve => {
                                setTimeout(() => {
                                    const cellSizeMinusOne = this.cellSize - 1;
                                    const originalCoordinates = [
                                        [col * this.cellSize, row * this.cellSize],
                                        [col * this.cellSize, row * this.cellSize + cellSizeMinusOne],
                                        [col * this.cellSize + cellSizeMinusOne, row * this.cellSize + cellSizeMinusOne],
                                        [col * this.cellSize + cellSizeMinusOne, row * this.cellSize]
                                    ];

                                    // è®¡ç®—è¯¥æ ¼å­çš„åœˆå±‚ï¼ˆä»0å¼€å§‹ï¼‰
                                    const cellLayer = Math.min(row, col, this.rows - 1 - row, this.cols - 1 - col);

                                    if (this.mapAngle === 0) {
                                        this.cells.push({
                                            id, row, col, layer: cellLayer,
                                            x: col * this.cellSize,
                                            y: row * this.cellSize,
                                            coordinates: originalCoordinates,
                                            originalCoordinates,
                                            resources: []
                                        });
                                    } else {
                                        const angleRad = this.mapAngle * Math.PI / 180;
                                        const cosAngle = Math.cos(angleRad);
                                        const sinAngle = Math.sin(angleRad);

                                        const coordinates = originalCoordinates.map(([x, y]) => {
                                            const tx = x * cosAngle - y * sinAngle;
                                            const ty = x * sinAngle + y * cosAngle;
                                            return [tx, ty];
                                        });

                                        this.cells.push({
                                            id, row, col, layer: cellLayer,
                                            x: col * this.cellSize,
                                            y: row * this.cellSize,
                                            coordinates,
                                            originalCoordinates,
                                            resources: []
                                        });
                                    }

                                    currentProgress++;
                                    this.updateLoadingProgress((currentProgress / steps) * 100);
                                    resolve();
                                }, stepDelay);
                            });
                        };

                        // å¹¶å‘ç”Ÿæˆå½“å‰åœˆå±‚çš„æ ¼å­
                        const promises = [];
                        for (let col = leftCol; col <= rightCol; col++) {
                            promises.push(generateCell(bottomRow, col, cellId++));
                        }
                        for (let row = bottomRow + 1; row <= topRow; row++) {
                            promises.push(generateCell(row, rightCol, cellId++));
                        }
                        for (let col = rightCol - 1; col >= leftCol; col--) {
                            promises.push(generateCell(topRow, col, cellId++));
                        }
                        for (let row = topRow - 1; row > bottomRow; row--) {
                            promises.push(generateCell(row, leftCol, cellId++));
                        }

                        await Promise.all(promises);
                    }

                    // ç”Ÿæˆå®Œæˆåï¼Œç¡®ä¿è¿›åº¦ä¸º100%
                    this.updateLoadingProgress(100);

                    // åˆå§‹åŒ– cell.resourcesï¼ˆæ¯æ¬¡ç”Ÿæˆéƒ½ä¼šæ¸…ç©ºä¹‹å‰çš„èµ„æºåˆ†é…ï¼‰
                    for (const c of this.cells) {
                        c.resources = []; // æ¯é¡¹ä¸º { type, id, qty }
                    }
                }

                // ========== èµ„æºé¢„è§ˆå’Œåˆ†æåŠŸèƒ½ ==========

                // èµ„æºé¢„è§ˆåŠŸèƒ½
                previewResources() {
                    if (!this.cells || this.cells.length === 0) {
                        this.showAnimatedNotification('è¯·å…ˆç”Ÿæˆåœ°å›¾', 'warning', 3000);
                        return;
                    }

                    // æ˜¾ç¤ºé¢„è§ˆé¢æ¿
                    document.getElementById('resourcePreviewPanel').style.display = 'block';
                    document.getElementById('conflictDetectionPanel').style.display = 'none';
                    document.getElementById('advancedStatsPanel').style.display = 'none';

                    // ç”Ÿæˆå¯†åº¦çƒ­åŠ›å›¾
                    this.generateDensityMap();

                    // ç”Ÿæˆä¼˜åŒ–å»ºè®®
                    this.generateOptimizationSuggestions();

                    this.showAnimatedNotification('èµ„æºé¢„è§ˆå·²ç”Ÿæˆ', 'success', 2500);
                }

                // ç”Ÿæˆå¯†åº¦çƒ­åŠ›å›¾
                generateDensityMap() {
                    const container = document.getElementById('densityMapContainer');

                    // è·å–å½“å‰é€‰æ‹©çš„èµ„æºç±»å‹ç­›é€‰å™¨
                    const selectedFilter = document.querySelector('input[name="heatmapFilter"]:checked').value;

                    // æ ¹æ®ç­›é€‰å™¨ç±»å‹è¿‡æ»¤èµ„æº
                    const filteredCells = this.cells.map(cell => {
                        let filteredResources = cell.resources;
                        if (selectedFilter !== 'all') {
                            const filterType = parseInt(selectedFilter);
                            filteredResources = cell.resources.filter(r => r.type === filterType);
                        }
                        return {
                            ...cell,
                            filteredResources: filteredResources,
                            density: filteredResources.reduce((sum, r) => sum + r.qty, 0)
                        };
                    });

                    // è®¡ç®—æœ€å¤§å¯†åº¦
                    const maxDensity = filteredCells.reduce((max, cell) => {
                        return Math.max(max, cell.density);
                    }, 1);

                    // æ›´æ–°å›¾ä¾‹è¯´æ˜
                    const legendText = selectedFilter === 'all' ? 'æ‰€æœ‰èµ„æº' :
                                       selectedFilter === '1' ? 'æ€ªç‰©' :
                                       selectedFilter === '2' ? 'èµ„æº' : 'è”ç›Ÿèµ„æº';
                    document.getElementById('heatmapLegend').textContent = `${legendText} å¯†åº¦: ä½ â†’ é«˜`;

                    // åˆ›å»ºçƒ­åŠ›å›¾
                    let heatmapHTML = '<div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 2px; width: 100%; height: 100%;">';

                    const sampleSize = Math.min(64, filteredCells.length); // æœ€å¤šæ˜¾ç¤º64ä¸ªæ ¼å­
                    const step = Math.floor(filteredCells.length / sampleSize);

                    for (let i = 0; i < filteredCells.length && i < sampleSize * step; i += step) {
                        const cell = filteredCells[i];
                        const density = cell.density;
                        const intensity = density / maxDensity;

                        // æ ¹æ®å¯†åº¦ç”Ÿæˆé¢œè‰² - ä½¿ç”¨ä¸åŒçš„è‰²å½©æ–¹æ¡ˆåŒºåˆ†èµ„æºç±»å‹
                        let color;
                        if (intensity === 0) {
                            color = '#f8f9fa'; // ç°ç™½è‰² - æ— èµ„æº
                        } else {
                            // æ ¹æ®èµ„æºç±»å‹ä½¿ç”¨ä¸åŒçš„åŸºç¡€é¢œè‰²
                            if (selectedFilter === '1') { // æ€ªç‰© - çº¢è‰²ç³»
                                if (intensity < 0.3) color = '#f8d7da';
                                else if (intensity < 0.6) color = '#f5c6cb';
                                else if (intensity < 0.8) color = '#f1b0b7';
                                else color = '#dc3545';
                            } else if (selectedFilter === '2') { // èµ„æº - è“è‰²ç³»
                                if (intensity < 0.3) color = '#d1ecf1';
                                else if (intensity < 0.6) color = '#bee5eb';
                                else if (intensity < 0.8) color = '#abdde5';
                                else color = '#0c5460';
                            } else if (selectedFilter === '3') { // è”ç›Ÿèµ„æº - ç»¿è‰²ç³»
                                if (intensity < 0.3) color = '#d4edda';
                                else if (intensity < 0.6) color = '#c3e6cb';
                                else if (intensity < 0.8) color = '#b1dfbb';
                                else color = '#155724';
                            } else { // æ‰€æœ‰èµ„æº - æ··åˆè‰²ç³»
                                if (intensity < 0.3) color = '#d4edda';
                                else if (intensity < 0.6) color = '#fff3cd';
                                else if (intensity < 0.8) color = '#f8d7da';
                                else color = '#dc3545';
                            }
                        }

                        const resourceTypeText = selectedFilter === 'all' ? 'èµ„æº' :
                                              selectedFilter === '1' ? 'æ€ªç‰©' :
                                              selectedFilter === '2' ? 'èµ„æº' : 'è”ç›Ÿèµ„æº';
                        heatmapHTML += `<div style="background: ${color}; border-radius: 2px; cursor: pointer;" title="æ ¼å­${cell.id}: ${density}ä¸ª${resourceTypeText}"></div>`;
                    }

                    heatmapHTML += '</div>';
                    container.innerHTML = heatmapHTML;
                }

                // ç”Ÿæˆä¼˜åŒ–å»ºè®®
                generateOptimizationSuggestions() {
                    const suggestions = [];

                    // åˆ†æèµ„æºåˆ†å¸ƒ
                    const totalResources = this.cells.reduce((sum, cell) => {
                        return sum + cell.resources.reduce((rSum, r) => rSum + r.qty, 0);
                    }, 0);

                    const occupiedCells = this.cells.filter(cell => cell.resources.length > 0).length;
                    const emptyCells = this.cells.length - occupiedCells;

                    if (emptyCells > this.cells.length * 0.7) {
                        suggestions.push('ğŸ¯ å»ºè®®ï¼šå½“å‰æœ‰70%ä»¥ä¸Šçš„æ ¼å­ä¸ºç©ºï¼Œå¯ä»¥è€ƒè™‘å¢åŠ èµ„æºåˆ†å¸ƒå¯†åº¦');
                    }

                    if (totalResources > 0 && occupiedCells > 0) {
                        const avgResourcesPerCell = totalResources / occupiedCells;
                        if (avgResourcesPerCell > 5) {
                            suggestions.push('âš–ï¸ å»ºè®®ï¼šéƒ¨åˆ†æ ¼å­èµ„æºè¿‡äºé›†ä¸­ï¼Œå»ºè®®åˆ†æ•£åˆ†å¸ƒä»¥æå‡è¦†ç›–èŒƒå›´');
                        }
                    }

                    // åˆ†æåœˆå±‚åˆ†å¸ƒ
                    const layerDistribution = {};
                    this.cells.forEach(cell => {
                        if (cell.resources.length > 0) {
                            layerDistribution[cell.layer] = (layerDistribution[cell.layer] || 0) + cell.resources.length;
                        }
                    });

                    const layerCounts = Object.values(layerDistribution);
                    if (layerCounts.length > 1) {
                        const maxLayer = Math.max(...layerCounts);
                        const minLayer = Math.min(...layerCounts);
                        if (maxLayer > minLayer * 3) {
                            suggestions.push('ğŸ”„ å»ºè®®ï¼šèµ„æºåœ¨åœˆå±‚é—´åˆ†å¸ƒä¸å‡è¡¡ï¼Œå»ºè®®è°ƒæ•´å„åœˆå±‚çš„èµ„æºåˆ†é…');
                        }
                    }

                    if (suggestions.length === 0) {
                        suggestions.push('âœ… å½“å‰èµ„æºåˆ†å¸ƒè¾ƒä¸ºåˆç†ï¼Œæ— éœ€ç‰¹åˆ«è°ƒæ•´');
                    }

                    document.getElementById('optimizationSuggestions').innerHTML = suggestions.join('<br>');
                }

                // å†²çªæ£€æµ‹åŠŸèƒ½
                detectResourceConflicts() {
                    if (!this.cells || this.cells.length === 0) {
                        this.showAnimatedNotification('è¯·å…ˆç”Ÿæˆåœ°å›¾', 'warning', 3000);
                        return;
                    }

                    // æ˜¾ç¤ºå†²çªæ£€æµ‹é¢æ¿
                    document.getElementById('conflictDetectionPanel').style.display = 'block';
                    document.getElementById('resourcePreviewPanel').style.display = 'none';
                    document.getElementById('advancedStatsPanel').style.display = 'none';

                    const conflicts = this.analyzeConflicts();
                    this.displayConflictReport(conflicts);

                    this.showAnimatedNotification(`æ£€æµ‹å®Œæˆï¼Œå‘ç°${conflicts.length}ä¸ªæ½œåœ¨å†²çª`, conflicts.length > 0 ? 'warning' : 'success', 3000);
                }

                // åˆ†æèµ„æºå†²çª
                analyzeConflicts() {
                    const conflicts = [];

                    // æ£€æŸ¥é‡å¤èµ„æºåˆ†é…
                    const resourceMap = new Map();
                    this.cells.forEach(cell => {
                        cell.resources.forEach(resource => {
                            const key = `${cell.id}_${resource.type}_${resource.id}`;
                            if (resourceMap.has(key)) {
                                conflicts.push({
                                    type: 'é‡å¤åˆ†é…',
                                    cellId: cell.id,
                                    resourceId: resource.id,
                                    description: `æ ¼å­${cell.id}ä¸­èµ„æº${resource.id}è¢«é‡å¤åˆ†é…`
                                });
                            } else {
                                resourceMap.set(key, { cell, resource });
                            }
                        });
                    });

                    // æ£€æŸ¥æ•°é‡å¼‚å¸¸
                    this.cells.forEach(cell => {
                        cell.resources.forEach(resource => {
                            if (resource.qty <= 0) {
                                conflicts.push({
                                    type: 'æ•°é‡å¼‚å¸¸',
                                    cellId: cell.id,
                                    resourceId: resource.id,
                                    description: `æ ¼å­${cell.id}ä¸­èµ„æº${resource.id}æ•°é‡ä¸º${resource.qty}ï¼Œå¯èƒ½å­˜åœ¨é—®é¢˜`
                                });
                            }
                        });
                    });

                    // æ£€æŸ¥èµ„æºå¯†åº¦è¿‡é«˜
                    this.cells.forEach(cell => {
                        const totalQty = cell.resources.reduce((sum, r) => sum + r.qty, 0);
                        if (totalQty > 20) {
                            conflicts.push({
                                type: 'å¯†åº¦è¿‡é«˜',
                                cellId: cell.id,
                                resourceId: 'multiple',
                                description: `æ ¼å­${cell.id}èµ„æºæ€»é‡è¿‡é«˜(${totalQty})ï¼Œå¯èƒ½å½±å“æ€§èƒ½`
                            });
                        }
                    });

                    return conflicts;
                }

                // æ˜¾ç¤ºå†²çªæŠ¥å‘Š
                displayConflictReport(conflicts) {
                    const reportElement = document.getElementById('conflictReport');

                    if (conflicts.length === 0) {
                        reportElement.innerHTML = 'âœ… æœªå‘ç°èµ„æºå†²çªï¼Œèµ„æºé…ç½®è‰¯å¥½ï¼';
                        return;
                    }

                    // æŒ‰ç±»å‹åˆ†ç»„å†²çª
                    const conflictsByType = {};
                    conflicts.forEach(conflict => {
                        if (!conflictsByType[conflict.type]) {
                            conflictsByType[conflict.type] = [];
                        }
                        conflictsByType[conflict.type].push(conflict);
                    });

                    let reportHTML = `<strong>å‘ç° ${conflicts.length} ä¸ªæ½œåœ¨å†²çªï¼š</strong><br><br>`;

                    Object.entries(conflictsByType).forEach(([type, typeConflicts]) => {
                        reportHTML += `<strong>${type} (${typeConflicts.length}ä¸ª):</strong><br>`;
                        typeConflicts.slice(0, 3).forEach(conflict => {
                            reportHTML += `â€¢ ${conflict.description}<br>`;
                        });
                        if (typeConflicts.length > 3) {
                            reportHTML += `â€¢ ... è¿˜æœ‰${typeConflicts.length - 3}ä¸ªç±»ä¼¼é—®é¢˜<br>`;
                        }
                        reportHTML += '<br>';
                    });

                    reportElement.innerHTML = reportHTML;
                }

                // é«˜çº§ç»Ÿè®¡åŠŸèƒ½
                showAdvancedStatistics() {
                    if (!this.cells || this.cells.length === 0) {
                        this.showAnimatedNotification('è¯·å…ˆç”Ÿæˆåœ°å›¾', 'warning', 3000);
                        return;
                    }

                    // æ˜¾ç¤ºé«˜çº§ç»Ÿè®¡é¢æ¿
                    document.getElementById('advancedStatsPanel').style.display = 'block';
                    document.getElementById('resourcePreviewPanel').style.display = 'none';
                    document.getElementById('conflictDetectionPanel').style.display = 'none';

                    // ç”Ÿæˆè¯¦ç»†ç»Ÿè®¡
                    this.generateDetailedStats();

                    // ç”Ÿæˆå¯è§†åŒ–å›¾è¡¨
                    this.generateVisualizationChart();

                    // ç”Ÿæˆåœˆå±‚åˆ†æ
                    this.generateLayerAnalysis();

                    this.showAnimatedNotification('é«˜çº§ç»Ÿè®¡æŠ¥å‘Šå·²ç”Ÿæˆ', 'success', 2500);
                }

                // ç”Ÿæˆè¯¦ç»†ç»Ÿè®¡
                generateDetailedStats() {
                    const stats = {
                        totalCells: this.cells.length,
                        occupiedCells: this.cells.filter(cell => cell.resources.length > 0).length,
                        totalResources: 0,
                        resourceTypes: {},
                        layerStats: {}
                    };

                    this.cells.forEach(cell => {
                        // ç»Ÿè®¡èµ„æº
                        cell.resources.forEach(resource => {
                            stats.totalResources += resource.qty;

                            const typeKey = resource.type === 1 ? 'æ€ªç‰©' : 'èµ„æº';
                            if (!stats.resourceTypes[typeKey]) {
                                stats.resourceTypes[typeKey] = { count: 0, quantity: 0 };
                            }
                            stats.resourceTypes[typeKey].count++;
                            stats.resourceTypes[typeKey].quantity += resource.qty;
                        });

                        // ç»Ÿè®¡åœˆå±‚
                        const layer = cell.layer;
                        if (!stats.layerStats[layer]) {
                            stats.layerStats[layer] = { cells: 0, resources: 0 };
                        }
                        if (cell.resources.length > 0) {
                            stats.layerStats[layer].cells++;
                            stats.layerStats[layer].resources += cell.resources.reduce((sum, r) => sum + r.qty, 0);
                        }
                    });

                    // ç”Ÿæˆç»Ÿè®¡æŠ¥å‘ŠHTML
                    let statsHTML = `
                        <strong>ğŸ“Š åŸºç¡€ç»Ÿè®¡ï¼š</strong><br>
                        â€¢ æ€»æ ¼å­æ•°ï¼š${stats.totalCells}<br>
                        â€¢ å·²å ç”¨æ ¼å­ï¼š${stats.occupiedCells} (${(stats.occupiedCells/stats.totalCells*100).toFixed(1)}%)<br>
                        â€¢ æ€»èµ„æºæ•°é‡ï¼š${stats.totalResources}<br><br>

                        <strong>ğŸ“¦ èµ„æºç±»å‹åˆ†å¸ƒï¼š</strong><br>
                    `;

                    Object.entries(stats.resourceTypes).forEach(([type, data]) => {
                        statsHTML += `â€¢ ${type}ï¼š${data.count}ç§ï¼Œå…±${data.quantity}ä¸ª<br>`;
                    });

                    statsHTML += `<br><strong>ğŸ¯ åˆ†å¸ƒå¯†åº¦ï¼š</strong><br>`;
                    if (stats.occupiedCells > 0) {
                        const avgDensity = (stats.totalResources / stats.occupiedCells).toFixed(2);
                        statsHTML += `â€¢ å¹³å‡å¯†åº¦ï¼š${avgDensity} ä¸ªèµ„æº/æ ¼å­<br>`;
                    }

                    document.getElementById('detailedStats').innerHTML = statsHTML;
                }

                // ç”Ÿæˆå¯è§†åŒ–å›¾è¡¨
                generateVisualizationChart() {
                    const canvas = document.getElementById('statsChart');
                    const placeholder = document.getElementById('chartPlaceholder');

                    // ç»Ÿè®¡èµ„æºç±»å‹åˆ†å¸ƒ
                    const resourceStats = { æ€ªç‰©: 0, èµ„æº: 0 };
                    this.cells.forEach(cell => {
                        cell.resources.forEach(resource => {
                            const type = resource.type === 1 ? 'æ€ªç‰©' : 'èµ„æº';
                            resourceStats[type] += resource.qty;
                        });
                    });

                    // æ˜¾ç¤ºcanvasï¼Œéšè—placeholder
                    canvas.style.display = 'block';
                    placeholder.style.display = 'none';

                    // ç»˜åˆ¶ç®€å•çš„æŸ±çŠ¶å›¾
                    const ctx = canvas.getContext('2d');
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;

                    const data = Object.entries(resourceStats);
                    const maxValue = Math.max(...data.map(d => d[1]), 1);
                    const barWidth = canvas.width / (data.length * 2);
                    const barSpacing = barWidth;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    data.forEach(([label, value], index) => {
                        const barHeight = (value / maxValue) * (canvas.height - 30);
                        const x = barSpacing + index * (barWidth + barSpacing);
                        const y = canvas.height - barHeight - 20;

                        // ç»˜åˆ¶æŸ±å­
                        ctx.fillStyle = label === 'æ€ªç‰©' ? '#ff6b6b' : '#4ecdc4';
                        ctx.fillRect(x, y, barWidth, barHeight);

                        // ç»˜åˆ¶æ ‡ç­¾
                        ctx.fillStyle = '#333';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(label, x + barWidth/2, canvas.height - 5);
                        ctx.fillText(value, x + barWidth/2, y - 5);
                    });
                }

                // ç”Ÿæˆåœˆå±‚åˆ†æ
                generateLayerAnalysis() {
                    const layerStats = {};
                    const maxLayer = Math.max(...this.cells.map(c => c.layer));

                    for (let i = 0; i <= maxLayer; i++) {
                        layerStats[i] = { cells: 0, resources: 0 };
                    }

                    this.cells.forEach(cell => {
                        layerStats[cell.layer].cells++;
                        layerStats[cell.layer].resources += cell.resources.reduce((sum, r) => sum + r.qty, 0);
                    });

                    let analysisHTML = '<strong>ğŸ“Š å„åœˆå±‚èµ„æºåˆ†å¸ƒï¼š</strong><br>';
                    Object.entries(layerStats).forEach(([layer, stats]) => {
                        const totalResources = Object.values(layerStats).reduce((sum, s) => sum + s.resources, 0);
                        const percentage = totalResources > 0 ? ((stats.resources / totalResources) * 100).toFixed(1) : 0;
                        analysisHTML += `â€¢ åœˆå±‚${layer}ï¼š${stats.resources}ä¸ªèµ„æº (${percentage}%)<br>`;
                    });

                    document.getElementById('layerAnalysis').innerHTML = analysisHTML;
                }

                // è‡ªåŠ¨è§£å†³å†²çª
                autoResolveConflicts() {
                    const conflicts = this.analyzeConflicts();
                    let resolvedCount = 0;

                    conflicts.forEach(conflict => {
                        if (conflict.type === 'é‡å¤åˆ†é…') {
                            // ç§»é™¤é‡å¤çš„èµ„æº
                            const cell = this.cells.find(c => c.id === conflict.cellId);
                            if (cell) {
                                cell.resources = cell.resources.filter(r =>
                                    !(r.type.toString() === conflict.resourceId.split('_')[0] &&
                                      r.id.toString() === conflict.resourceId.split('_')[1])
                                );
                                resolvedCount++;
                            }
                        } else if (conflict.type === 'æ•°é‡å¼‚å¸¸') {
                            // ç§»é™¤æ•°é‡å¼‚å¸¸çš„èµ„æº
                            const cell = this.cells.find(c => c.id === conflict.cellId);
                            if (cell) {
                                cell.resources = cell.resources.filter(r => r.qty > 0);
                                resolvedCount++;
                            }
                        }
                    });

                    this.drawMap();
                    this.detectResourceConflicts(); // é‡æ–°æ£€æµ‹
                    this.showAnimatedNotification(`å·²è‡ªåŠ¨è§£å†³${resolvedCount}ä¸ªå†²çª`, 'success', 3000);
                }

                // æ‰‹åŠ¨è°ƒæ•´æ¨¡å¼
                startManualAdjustment() {
                    this.showAnimatedNotification('æ‰‹åŠ¨è°ƒæ•´æ¨¡å¼ï¼šç‚¹å‡»åœ°å›¾ä¸Šçš„æ ¼å­è¿›è¡Œç¼–è¾‘', 'info', 4000);
                    // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤šæ‰‹åŠ¨è°ƒæ•´çš„é€»è¾‘
                }

                // å¯¼å‡ºè¯¦ç»†æŠ¥å‘Š
                exportDetailedReport() {
                    const report = this.generateDetailedReport();
                    const blob = new Blob([report], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `èµ„æºåˆ†ææŠ¥å‘Š_${new Date().toISOString().slice(0,10)}.txt`;
                    a.click();
                    URL.revokeObjectURL(url);

                    this.showAnimatedNotification('è¯¦ç»†æŠ¥å‘Šå·²å¯¼å‡º', 'success', 2500);
                }

                // ç”Ÿæˆè¯¦ç»†æŠ¥å‘Šå†…å®¹
                generateDetailedReport() {
                    const timestamp = new Date().toLocaleString('zh-CN');

                    let report = `èµ„æºåˆ†ææŠ¥å‘Š\nç”Ÿæˆæ—¶é—´ï¼š${timestamp}\n${'='.repeat(50)}\n\n`;

                    // åŸºç¡€ç»Ÿè®¡
                    const totalCells = this.cells.length;
                    const occupiedCells = this.cells.filter(cell => cell.resources.length > 0).length;
                    const totalResources = this.cells.reduce((sum, cell) =>
                        sum + cell.resources.reduce((rSum, r) => rSum + r.qty, 0), 0);

                    report += `åŸºç¡€ç»Ÿè®¡\n${'-'.repeat(20)}\n`;
                    report += `æ€»æ ¼å­æ•°ï¼š${totalCells}\n`;
                    report += `å·²å ç”¨æ ¼å­ï¼š${occupiedCells} (${(occupiedCells/totalCells*100).toFixed(1)}%)\n`;
                    report += `æ€»èµ„æºæ•°é‡ï¼š${totalResources}\n\n`;

                    // èµ„æºç±»å‹ç»Ÿè®¡
                    const resourceTypes = { æ€ªç‰©: 0, èµ„æº: 0 };
                    this.cells.forEach(cell => {
                        cell.resources.forEach(resource => {
                            const type = resource.type === 1 ? 'æ€ªç‰©' : 'èµ„æº';
                            resourceTypes[type] += resource.qty;
                        });
                    });

                    report += `èµ„æºç±»å‹åˆ†å¸ƒ\n${'-'.repeat(20)}\n`;
                    Object.entries(resourceTypes).forEach(([type, count]) => {
                        report += `${type}ï¼š${count}ä¸ª\n`;
                    });
                    report += '\n';

                    // åœˆå±‚åˆ†æ
                    const layerStats = {};
                    this.cells.forEach(cell => {
                        if (!layerStats[cell.layer]) {
                            layerStats[cell.layer] = { cells: 0, resources: 0 };
                        }
                        if (cell.resources.length > 0) {
                            layerStats[cell.layer].cells++;
                            layerStats[cell.layer].resources += cell.resources.reduce((sum, r) => sum + r.qty, 0);
                        }
                    });

                    report += `åœˆå±‚åˆ†å¸ƒåˆ†æ\n${'-'.repeat(20)}\n`;
                    Object.entries(layerStats)
                        .sort(([a], [b]) => parseInt(a) - parseInt(b))
                        .forEach(([layer, stats]) => {
                            report += `åœˆå±‚${layer}ï¼š${stats.cells}ä¸ªæ ¼å­ï¼Œ${stats.resources}ä¸ªèµ„æº\n`;
                        });

                    // å†²çªæ£€æµ‹
                    const conflicts = this.analyzeConflicts();
                    report += `\nå†²çªæ£€æµ‹ç»“æœ\n${'-'.repeat(20)}\n`;
                    if (conflicts.length === 0) {
                        report += 'âœ… æœªå‘ç°å†²çª\n';
                    } else {
                        report += `å‘ç°${conflicts.length}ä¸ªæ½œåœ¨å†²çªï¼š\n`;
                        conflicts.forEach((conflict, index) => {
                            report += `${index + 1}. ${conflict.description}\n`;
                        });
                    }

                    return report;
                }

                // ========== ä¸»é¢˜ç›¸å…³åŠŸèƒ½ ==========

                // åˆ‡æ¢ç•Œé¢ä¸»é¢˜
                switchUITheme(theme) {
                    // ç§»é™¤æ‰€æœ‰ä¸»é¢˜ç±»
                    document.body.classList.remove('light-theme', 'dark-theme');

                    // æ·»åŠ æ–°ä¸»é¢˜ç±»
                    if (theme !== 'light') {
                        document.body.classList.add(`${theme}-theme`);
                    }

                    this.currentUITheme = theme;
                    this.saveThemeSettings(); // ä¿å­˜è®¾ç½®
                    this.showAnimatedNotification(`å·²åˆ‡æ¢åˆ°${theme === 'light' ? 'æµ…è‰²' : 'æ·±è‰²'}ä¸»é¢˜`, 'success', 2000);
                }

                // åˆ‡æ¢æ ¼å­é¢œè‰²ä¸»é¢˜
                switchCellTheme(theme) {
                    this.currentCellTheme = theme;

                    // å¦‚æœåˆ‡æ¢åˆ°è‡ªå®šä¹‰ä¸»é¢˜ï¼Œé€‰æ‹©å¯¹åº”çš„radioæŒ‰é’®
                    if (theme === 'custom') {
                        document.querySelector('input[name="cellTheme"][value="custom"]').checked = true;
                    }

                    this.drawMap();
                    this.saveThemeSettings(); // ä¿å­˜è®¾ç½®
                    this.showAnimatedNotification(`å·²åˆ‡æ¢åˆ°${this.getThemeDisplayName(theme)}`, 'success', 2000);
                }

                // è·å–æ ¼å­ä¸»é¢˜é¢œè‰²
                getCellThemeColor(row, col, layer) {
                    switch (this.currentCellTheme) {
                        case 'default':
                            return ((row + col) % 2 === 0 ? this.cellThemes.default.odd : this.cellThemes.default.even);

  
                        case 'spring':
                            return ((row + col) % 2 === 0 ? this.cellThemes.spring.odd : this.cellThemes.spring.even);

                        case 'summer':
                            return ((row + col) % 2 === 0 ? this.cellThemes.summer.odd : this.cellThemes.summer.even);

                        case 'autumn':
                            return ((row + col) % 2 === 0 ? this.cellThemes.autumn.odd : this.cellThemes.autumn.even);

                        case 'winter':
                            return ((row + col) % 2 === 0 ? this.cellThemes.winter.odd : this.cellThemes.winter.even);

    
                        default:
                            return '#ffffff';
                    }
                }

                // è·å–ä¸»é¢˜æ˜¾ç¤ºåç§°
                getThemeDisplayName(theme) {
                    const themeNames = {
                        'default': 'é»˜è®¤é…è‰²',
                        'spring': 'æ˜¥å­£ä¸»é¢˜',
                        'summer': 'å¤å­£ä¸»é¢˜',
                        'autumn': 'ç§‹å­£ä¸»é¢˜',
                        'winter': 'å†¬å­£ä¸»é¢˜'
                    };
                    return themeNames[theme] || theme;
                }

  
                // é¢„è®¾ä¸»é¢˜å¿«é€Ÿåˆ‡æ¢æ–¹æ³•
                applyPresetTheme(presetName) {
                    const presets = {
                        'nature': {
                            cellTheme: 'spring',
                            uiTheme: 'light'
                        },
                        'night': {
                            cellTheme: 'game',
                            uiTheme: 'dark'
                        },
                        'accessibility': {
                            cellTheme: 'high-contrast',
                            uiTheme: 'high-contrast'
                        }
                    };

                    if (presets[presetName]) {
                        const preset = presets[presetName];
                        this.switchUITheme(preset.uiTheme);
                        this.switchCellTheme(preset.cellTheme);

                        // æ›´æ–°UIé€‰æ‹©å™¨
                        document.querySelector(`input[name="uiTheme"][value="${preset.uiTheme}"]`).checked = true;
                        document.querySelector(`input[name="cellTheme"][value="${preset.cellTheme}"]`).checked = true;

                        this.showAnimatedNotification(`å·²åº”ç”¨${presetName}é¢„è®¾ä¸»é¢˜`, 'success', 2000);
                    }
                }

                // ä¿å­˜ä¸»é¢˜è®¾ç½®åˆ°æœ¬åœ°å­˜å‚¨
                saveThemeSettings() {
                    const settings = {
                        uiTheme: this.currentUITheme,
                        cellTheme: this.currentCellTheme
                    };
                    localStorage.setItem('mapThemeSettings', JSON.stringify(settings));
                }

                // ä»æœ¬åœ°å­˜å‚¨åŠ è½½ä¸»é¢˜è®¾ç½®
                loadThemeSettings() {
                    try {
                        const saved = localStorage.getItem('mapThemeSettings');
                        if (saved) {
                            const settings = JSON.parse(saved);
                            this.currentUITheme = settings.uiTheme || 'light';
                            this.currentCellTheme = settings.cellTheme || 'default';

                            // åº”ç”¨ä¿å­˜çš„ä¸»é¢˜
                            this.switchUITheme(this.currentUITheme);
                            this.switchCellTheme(this.currentCellTheme);

                            // æ›´æ–°UIé€‰æ‹©å™¨
                            document.querySelector(`input[name="uiTheme"][value="${this.currentUITheme}"]`).checked = true;
                            document.querySelector(`input[name="cellTheme"][value="${this.currentCellTheme}"]`).checked = true;

                                        }
                    } catch (error) {
                        console.warn('æ— æ³•åŠ è½½ä¸»é¢˜è®¾ç½®:', error);
                    }
                }
            }

            // instantiate
            window.addEventListener('DOMContentLoaded', () => {
                window.mapTools = new MapTools();
            });
        </script>
        <script src="layout-toggle.js"></script>
    </body>

</html>