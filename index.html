<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>地图格子生成工具</title>
    <style>
        :root{
            --old-control-width: 320px;
            --new-control-width: calc(var(--old-control-width) * 0.8); /* 80% of previous */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
        }

        /* 三列布局：左、 中、 右 */
        .container {
            display: grid;
            grid-template-columns: var(--new-control-width) var(--new-control-width) 1fr;
            gap: 20px;
            max-width: 1400px;
            width: 100%;
            align-items: start;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 100%;
        }

        .layer-panel {
            /* 第二列容器 */
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 100%;
        }

        .controls h1, .layer-panel h1 {
            font-size: 20px;
            margin-bottom: 12px;
            color: #333;
            text-align: center;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }

        .input-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .input-hint {
            display: block;
            margin-top: 3px;
            font-size: 11px;
            color: #888;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        #generateBtn {
            background-color: #007bff;
            color: white;
            grid-column: span 2;
        }

        #generateBtn:hover {
            background-color: #0056b3;
        }

        #zoomInBtn, #zoomOutBtn {
            background-color: #28a745;
            color: white;
        }

        #zoomInBtn:hover, #zoomOutBtn:hover {
            background-color: #1e7e34;
        }

        #printBtn {
            background-color: #dc3545;
            color: white;
            grid-column: span 2;
        }

        #printBtn:hover {
            background-color: #c82333;
        }

        .info-panel {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #e9ecef;
            margin-bottom: 12px;
        }

        .info-panel h3 {
            margin-bottom: 10px;
            color: #333;
        }

        #cellInfo {
            font-size: 14px;
            color: #666;
            line-height: 1.5;
        }

        .preset-btn {
            padding: 5px 8px;
            font-size: 12px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            color: #495057;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
        }

        .preset-btn.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }

        .layer-controls {
            background-color: transparent;
            padding: 0;
            border-radius: 4px;
        }

        .layer-controls label {
            display: block;
            font-weight: bold;
            margin-bottom: 6px;
            color: #333;
            font-size: 13px;
        }

        #layerSelect {
            width: 100%;
            height: 120px;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            margin-bottom: 8px;
            box-sizing: border-box;
        }

        #monsterSelect, #resourceSelect {
            width: 100%;
            height: 130px;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            margin-bottom: 6px;
            box-sizing: border-box;
        }

        #highlightBtn {
            background-color: #20c997;
            color: white;
            margin-right: 8px;
        }

        #clearHighlightBtn {
            background-color: #6c757d;
            color: white;
        }

        #applyMonsterBtn {
            background-color: #e67e22;
            color: white;
            margin-top: 6px;
        }

        #applyResourceBtn {
            background-color: #17a2b8;
            color: white;
            margin-top: 6px;
        }

        #exportResourceBtn {
            background-color: #6f42c1;
            color: white;
            margin-top: 6px;
        }

        .canvas-container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            min-width: 0;
        }

        #mapCanvas {
            border: 1px solid #ccc;
            cursor: crosshair;
            display: block;
            max-width: 100%;
            height: auto;
        }

        /* responsive: single column on narrow screens */
        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
            }

            #layerSelect {
                height: 140px;
            }

            .canvas-container {
                min-height: 360px;
            }
        }

        @media (max-width: 480px) {
            .button-group {
                grid-template-columns: 1fr;
            }

            #generateBtn, #printBtn {
                grid-column: span 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 第1列：参数 + 按钮 -->
        <div class="controls">
            <div class="input-group">
                <label for="mapWidth">地图宽度 (像素):</label>
                <input type="number" id="mapWidth" value="1199" min="100" max="2000">
                <small class="input-hint">范围: 100-2000像素（注意：此值表示最大坐标，例如 1199 表示 0..1199）</small>
            </div>
            <div class="input-group">
                <label for="mapHeight">地图高度 (像素):</label>
                <input type="number" id="mapHeight" value="1199" min="100" max="2000">
                <small class="input-hint">范围: 100-2000像素（注意：此值表示最大坐标，例如 1199 表示 0..1199）</small>
            </div>
            <div class="input-group">
                <label for="cellSize">格子边长 (像素):</label>
                <input type="number" id="cellSize" value="100" min="10" max="200">
                <small class="input-hint">范围: 10-200像素</small>
            </div>
            <div class="button-group">
                <button id="generateBtn">生成地图</button>
                <button id="zoomInBtn">放大</button>
                <button id="zoomOutBtn">缩小</button>
                <button id="printBtn">打印数据</button>
            </div>

            <div class="info-panel">
                <h3>格子信息</h3>
                <p id="cellInfo">点击格子查看详细信息</p>
            </div>
        </div>

        <!-- 第2列：圈层列表（多选） + 按类型的资源/怪物列表（多选） -->
        <div class="layer-panel">
            <div class="layer-controls">
                <label for="layerSelect">圈层列表（多选）</label>
                <select id="layerSelect" multiple></select>
                <div style="display:flex; gap:8px; margin-top:8px;">
                    <button id="highlightBtn">高亮选择</button>
                    <button id="clearHighlightBtn">清除高亮</button>
                </div>
                <hr style="margin:12px 0;">

                <label for="monsterSelect" style="margin-top:8px;">怪物列表（类型1，可多选）</label>
                <select id="monsterSelect" multiple></select>
                <div style="display:flex; gap:8px; margin-top:8px; align-items:center;">
                    <label style="font-size:13px;color:#333;">怪物数量：</label>
                    <input id="monsterQuantity" type="number" value="1" min="0" style="width:80px;padding:6px;border:1px solid #ddd;border-radius:4px;">
                    <button id="setMonsterQtyBtn" style="background:#007bff;color:#fff;padding:6px 8px;border-radius:4px;">设置</button>
                </div>
                <div style="display:flex; gap:8px; margin-top:8px;">
                    <button id="applyMonsterBtn">添加怪物到选择圈层</button>
                </div>

                <hr style="margin:12px 0;">

                <label for="resourceSelect" style="margin-top:8px;">资源列表（类型2，可多选）</label>
                <select id="resourceSelect" multiple></select>
                <div style="display:flex; gap:8px; margin-top:8px; align-items:center;">
                    <label style="font-size:13px;color:#333;">资源数量：</label>
                    <input id="resourceQuantity" type="number" value="1" min="0" style="width:80px;padding:6px;border:1px solid #ddd;border-radius:4px;">
                    <button id="setResourceQtyBtn" style="background:#007bff;color:#fff;padding:6px 8px;border-radius:4px;">设置</button>
                </div>
                <div style="display:flex; gap:8px; margin-top:8px;">
                    <button id="applyResourceBtn">添加资源到选择圈层</button>
                </div>
                <hr style="margin:10px 0;">
                <div style="display:flex; gap:8px; margin-top:10px;">
                    <button id="exportResourceBtn">导出(怪物先，空行，再资源)</button>
                </div>
            </div>
        </div>

        <!-- 第3列：画布 -->
        <div class="canvas-container">
            <canvas id="mapCanvas"></canvas>
        </div>
    </div>

    <!-- 先引入资源数据脚本（同步定义全局 MAP_RESOURCES），避免 fetch -->
    <script src="map-resources.js"></script>

    <script>
        class MapTools {
            constructor() {
                this.canvas = document.getElementById('mapCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvasContainer = document.querySelector('.canvas-container');
                this.cells = [];
                this.selectedCell = null;
                this.zoom = 1;
                this.mapWidth = 800;  // 用户输入，表示最大坐标（例如 1199 表示 0..1199）
                this.mapHeight = 600; // 用户输入，表示最大坐标
                this.cellSize = 100;
                this.mapAngle = 0; // 0 or 45

                // 实际像素宽高（因为坐标从0开始，长度 = maxCoord + 1）
                this.actualMapWidth = this.mapWidth + 1;
                this.actualMapHeight = this.mapHeight + 1;

                // 当前支持的圈层数（整数）
                this.maxLayers = 0;

                // 被选中高亮的圈层集合，存储为零基索引（layer 变量）
                this.highlightedLayers = new Set();

                // devicePixelRatio 支持
                this.dpr = window.devicePixelRatio || 1;

                // 拖拽相关
                this.isDragging = false;
                this.dragStartX = 0;
                this.dragStartY = 0;
                this.mapOffsetX = 0; // CSS 像素
                this.mapOffsetY = 0;

                // 资源相关
                this.allItems = []; // 原始数组含 type
                this.monsters = []; // type=1
                this.resources = []; // type=2

                this.initEventListeners();
                this.loadResourcesFromGlobal();
                this.generateMap();
            }

            initEventListeners() {
                document.getElementById('generateBtn').addEventListener('click', () => {
                    this.generateMap();
                });

                document.getElementById('zoomInBtn').addEventListener('click', () => {
                    this.changeZoom(0.1);
                });

                document.getElementById('zoomOutBtn').addEventListener('click', () => {
                    this.changeZoom(-0.1);
                });

                document.getElementById('printBtn').addEventListener('click', () => {
                    this.printData();
                });

                document.getElementById('highlightBtn').addEventListener('click', () => {
                    this.applyLayerHighlight();
                });

                document.getElementById('clearHighlightBtn').addEventListener('click', () => {
                    this.clearLayerHighlight();
                });

                document.getElementById('applyMonsterBtn').addEventListener('click', () => {
                    this.applyItemsToSelectedLayers(1);
                });

                document.getElementById('applyResourceBtn').addEventListener('click', () => {
                    this.applyItemsToSelectedLayers(2);
                });

                document.getElementById('exportResourceBtn').addEventListener('click', () => {
                    this.exportSeparatedData();
                });

                // Set quantity buttons for batch or single selection edits
                document.getElementById('setMonsterQtyBtn').addEventListener('click', () => {
                    this.setItemQuantity(1);
                });
                document.getElementById('setResourceQtyBtn').addEventListener('click', () => {
                    this.setItemQuantity(2);
                });

                // synchronize select -> quantity input when selection changes
                document.getElementById('monsterSelect').addEventListener('change', () => {
                    this.syncQuantityInputFromSelection(1);
                });
                document.getElementById('resourceSelect').addEventListener('change', () => {
                    this.syncQuantityInputFromSelection(2);
                });

                // unified event to map coordinate
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleCanvasHover(e));

                // dragging
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('mouseleave', (e) => this.handleMouseUp(e));

                // resize / dpr change
                window.addEventListener('resize', () => {
                    this.dpr = window.devicePixelRatio || 1;
                    this.updateCanvasSize();
                    this.drawMap();
                });
            }

            loadResourcesFromGlobal() {
                // 读取全局 MAP_RESOURCES（由 map-resources.js 提供）
                if (window.MAP_RESOURCES && Array.isArray(window.MAP_RESOURCES)) {
                    // 把数量标准化为非负整数（负数视为 0），默认 0
                    this.allItems = window.MAP_RESOURCES.map(i => {
                        const q = (i.qty != null) ? parseInt(i.qty) : 0;
                        const safeQ = isNaN(q) ? 0 : Math.max(0, q);
                        return { id: i.id, name: i.name, type: i.type, qty: safeQ };
                    });
                } else {
                    this.allItems = [];
                    console.warn('MAP_RESOURCES 未定义或格式不对，资源/怪物列表为空。');
                }

                this.monsters = this.allItems.filter(i => Number(i.type) === 1).map(i => Object.assign({}, i));
                this.resources = this.allItems.filter(i => Number(i.type) === 2).map(i => Object.assign({}, i));

                this.updateMonsterList();
                this.updateResourceList();
            }

            updateMonsterList() {
                const sel = document.getElementById('monsterSelect');
                sel.innerHTML = '';
                for (const r of this.monsters) {
                    const opt = document.createElement('option');
                    opt.value = String(r.id);
                    // 存储 qty 到 data 属性
                    const qtyVal = (r.qty != null) ? Number(r.qty) : 0;
                    const safeQty = isNaN(qtyVal) ? 0 : Math.max(0, qtyVal); // 负数显示为 0
                    opt.dataset.qty = String(safeQty);
                    // 在选项文本中显示数量（负值显示为 0）
                    opt.text = `${r.name} (${r.id}) (数量:${safeQty})`;
                    sel.appendChild(opt);
                }
                // try to sync quantity input when list refreshed
                this.syncQuantityInputFromSelection(1);
            }

            updateResourceList() {
                const sel = document.getElementById('resourceSelect');
                sel.innerHTML = '';
                for (const r of this.resources) {
                    const opt = document.createElement('option');
                    opt.value = String(r.id);
                    const qtyVal = (r.qty != null) ? Number(r.qty) : 0;
                    const safeQty = isNaN(qtyVal) ? 0 : Math.max(0, qtyVal);
                    opt.dataset.qty = String(safeQty);
                    opt.text = `${r.name} (${r.id}) (数量:${safeQty})`;
                    sel.appendChild(opt);
                }
                this.syncQuantityInputFromSelection(2);
            }

            // 当用户在列表中选择时，更新"每项数量"输入框显示
            // 若多选且所有选中项的数量相同，则显示该数量；否则清空输入框以提示用户这是混合值
            syncQuantityInputFromSelection(type) {
                const select = (type === 1) ? document.getElementById('monsterSelect') : document.getElementById('resourceSelect');
                const input = (type === 1) ? document.getElementById('monsterQuantity') : document.getElementById('resourceQuantity');
                const selectedOptions = Array.from(select.selectedOptions || []);
                if (selectedOptions.length === 0) {
                    // show nothing / keep default
                    // do not override user manual edits if none selected
                    return;
                }
                const qtys = selectedOptions.map(opt => {
                    const v = opt.dataset.qty;
                    const n = Number(v);
                    return isNaN(n) ? null : n;
                });
                const allSame = qtys.every(q => q === qtys[0]);
                if (allSame) {
                    input.value = qtys[0] != null ? qtys[0] : '';
                } else {
                    input.value = '';
                }
            }

            // 将输入框的数量设置到选中的列表项（支持多选批量设置，也支持单个设置）
            setItemQuantity(type) {
                const select = (type === 1) ? document.getElementById('monsterSelect') : document.getElementById('resourceSelect');
                const input = (type === 1) ? document.getElementById('monsterQuantity') : document.getElementById('resourceQuantity');
                let val = parseInt(input.value);
                if (isNaN(val)) {
                    alert('请输入有效数量（整数）。');
                    return;
                }
                // 负值视为 0
                val = Math.max(0, val);

                const selOpts = Array.from(select.selectedOptions || []);
                if (selOpts.length === 0) {
                    alert('请先在列表中选择一个或多个项，再设置数量。');
                    return;
                }
                // update underlying data arrays
                const arr = (type === 1) ? this.monsters : this.resources;
                for (const opt of selOpts) {
                    const idStr = String(opt.value);
                    opt.dataset.qty = String(val);
                    // 更新文本显示，保证旧有的 (数量:...) 会被替换
                    const base = this._getBaseTextForOption(opt.textContent || '', idStr);
                    opt.text = `${base} (数量:${val})`;
                    // 更新数组 entry
                    const found = arr.find(a => String(a.id) === idStr);
                    if (found) {
                        found.qty = val;
                    } else {
                        // 如果找不到，插入一项（保守处理）
                        arr.push({ id: idStr, name: base.split(' (')[0], type: type, qty: val });
                    }
                }
            }

            // helper to try to reconstruct base name/id text without existing (数量:...) suffix
            _getBaseTextForOption(fullText, idStr) {
                // fullText might be like: "名字 (123) (数量:5)" or "名字 (123)"
                // ensure we return "名字 (123)"
                const idToken = `(${idStr})`;
                const idx = fullText.indexOf(idToken);
                if (idx >= 0) {
                    return fullText.substring(0, idx + idToken.length).trim();
                }
                // fallback
                return fullText.split('(数量:')[0].trim();
            }

            generateMap() {
                // read inputs (用户输入表示最大坐标值)
                this.mapWidth = parseInt(document.getElementById('mapWidth').value) || this.mapWidth;
                this.mapHeight = parseInt(document.getElementById('mapHeight').value) || this.mapHeight;
                this.cellSize = parseInt(document.getElementById('cellSize').value) || this.cellSize;

                // 更新实际像素长度（坐标从0开始 => 长度 = 最大坐标 + 1）
                this.actualMapWidth = this.mapWidth + 1;
                this.actualMapHeight = this.mapHeight + 1;

                // validate ranges (基于用户输入的最大坐标)
                if (this.mapWidth < 100 || this.mapWidth > 2000 ||
                    this.mapHeight < 100 || this.mapHeight > 2000 ||
                    this.cellSize < 10 || this.cellSize > 200) {
                    alert('请输入有效的参数范围：\n地图边长(最大坐标): 100-2000 像素\n格子边长: 10-200像素');
                    return;
                }

                if (this.mapAngle !== 0 && this.mapAngle !== 45) {
                    alert('请选择有效的角度：0° 或 45°');
                    return;
                }

                // 新增校验：实际像素长度 (maxCoord + 1) 必须能被格子边长整除，否则停止生成并提示
                const msgs = [];
                if (this.actualMapWidth % this.cellSize !== 0) {
                    msgs.push(`(宽) 实际像素长度 ${this.actualMapWidth} 不能被格子边长 ${this.cellSize} 整除，余数: ${this.actualMapWidth % this.cellSize}`);
                }
                if (this.actualMapHeight % this.cellSize !== 0) {
                    msgs.push(`(高) 实际像素长度 ${this.actualMapHeight} 不能被格子边长 ${this.cellSize} 整除，余数: ${this.actualMapHeight % this.cellSize}`);
                }
                if (msgs.length) {
                    alert(msgs.join('\n') + '\n请调整参数 (注意：输入为最大坐标，实际像素长度 = 最大坐标 + 1)。');
                    return;
                }

                // 计算行列（使用实际像素长度 / 格子尺寸）
                this.cols = this.actualMapWidth / this.cellSize;
                this.rows = this.actualMapHeight / this.cellSize;

                // 生成格子（螺旋）
                this.generateCellsSpiral();

                // 初始化 cell.resources（每次生成都会清空之前的资源分配）
                for (const c of this.cells) {
                    c.resources = []; // 每项为 { type, id, qty }
                }

                // 计算圈层数（最大圈层）
                this.maxLayers = Math.ceil(Math.min(this.rows, this.cols) / 2);

                // 初始化层列表选择框
                this.updateLayerSelect();

                // Fit by available viewport height so map shows fully without vertical scroll
                const viewportHeight = window.innerHeight;
                const containerRect = this.canvasContainer.getBoundingClientRect();
                // available height below the top of the canvas container (leave small margin)
                const availableHeight = Math.max(100, viewportHeight - containerRect.top - 20);

                // fitZoom based on实际像素高度
                const fitZoom = availableHeight / this.actualMapHeight;
                this.zoom = Math.min(1, fitZoom);

                // reset highlighted layers when regenerate
                this.highlightedLayers.clear();
                this.updateLayerSelectSelection();

                this.updateCanvasSize();
                this.drawMap();
                this.updatePresetButtons();
            }

            generateCellsSpiral() {
                this.cells = [];
                let cellId = 1;
                const layers = Math.ceil(Math.min(this.rows, this.cols) / 2);

                for (let layer = 0; layer < layers; layer++) {
                    const topRow = this.rows - 1 - layer;
                    const bottomRow = layer;
                    const leftCol = layer;
                    const rightCol = this.cols - 1 - layer;

                    for (let col = leftCol; col <= rightCol; col++) this.addCell(bottomRow, col, cellId++);
                    for (let row = bottomRow + 1; row <= topRow; row++) this.addCell(row, rightCol, cellId++);
                    for (let col = rightCol - 1; col >= leftCol; col--) this.addCell(topRow, col, cellId++);
                    for (let row = topRow - 1; row > bottomRow; row--) this.addCell(row, leftCol, cellId++);
                }
            }

            addCell(row, col, id) {
                const cellSizeMinusOne = this.cellSize - 1;
                const originalCoordinates = [
                    [col * this.cellSize, row * this.cellSize],
                    [col * this.cellSize, row * this.cellSize + cellSizeMinusOne],
                    [col * this.cellSize + cellSizeMinusOne, row * this.cellSize + cellSizeMinusOne],
                    [col * this.cellSize + cellSizeMinusOne, row * this.cellSize]
                ];

                // 计算该格子的圈层（从0开始）
                const layer = Math.min(row, col, this.rows - 1 - row, this.cols - 1 - col);

                if (this.mapAngle === 0) {
                    this.cells.push({
                        id, row, col, layer,
                        x: col * this.cellSize,
                        y: row * this.cellSize,
                        coordinates: originalCoordinates,
                        originalCoordinates,
                        resources: []
                    });
                    return;
                }

                const angleRad = this.mapAngle * Math.PI / 180;
                const cosAngle = Math.cos(angleRad);
                const sinAngle = Math.sin(angleRad);

                const coordinates = originalCoordinates.map(([x, y]) => {
                    const tx = x * cosAngle - y * sinAngle;
                    const ty = x * sinAngle + y * cosAngle;
                    return [tx, ty];
                });

                this.cells.push({
                    id, row, col, layer,
                    x: col * this.cellSize,
                    y: row * this.cellSize,
                    coordinates,
                    originalCoordinates,
                    resources: []
                });
            }

            updateCanvasSize() {
                if (this.mapAngle === 0) {
                    const cssWidth = this.actualMapWidth * this.zoom;
                    const cssHeight = this.actualMapHeight * this.zoom;
                    this.canvas.width = Math.round(cssWidth * this.dpr);
                    this.canvas.height = Math.round(cssHeight * this.dpr);
                    this.canvas.style.width = cssWidth + 'px';
                    this.canvas.style.height = cssHeight + 'px';
                    this.mapOffsetX = 0;
                    this.mapOffsetY = 0;
                } else {
                    const angleRad = -this.mapAngle * Math.PI / 180;
                    const cosAngle = Math.cos(angleRad);
                    const sinAngle = Math.sin(angleRad);

                    const corners = [
                        [0, 0],
                        [0, this.actualMapHeight],
                        [this.actualMapWidth, this.actualMapHeight],
                        [this.actualMapWidth, 0]
                    ];

                    const transformed = corners.map(([x, y]) => {
                        return [x * cosAngle - y * sinAngle, x * sinAngle + y * cosAngle];
                    });

                    const minX = Math.min(...transformed.map(c => c[0]));
                    const maxX = Math.max(...transformed.map(c => c[0]));
                    const minY = Math.min(...transformed.map(c => c[1]));
                    const maxY = Math.max(...transformed.map(c => c[1]));

                    const padding = 20;
                    const cssWidth = (maxX - minX + padding * 2) * this.zoom;
                    const cssHeight = (maxY - minY + padding * 2) * this.zoom;

                    this.canvas.width = Math.round(cssWidth * this.dpr);
                    this.canvas.height = Math.round(cssHeight * this.dpr);
                    this.canvas.style.width = cssWidth + 'px';
                    this.canvas.style.height = cssHeight + 'px';

                    this.mapOffsetX = (-minX + padding) * this.zoom;
                    this.mapOffsetY = (-minY + padding) * this.zoom;
                }

                // If canvas CSS width exceeds container, scale CSS down to fit (not internal pixels)
                const containerRect = this.canvasContainer.getBoundingClientRect();
                const cssW = parseFloat(this.canvas.style.width) || (this.canvas.width / this.dpr);
                if (cssW > containerRect.width) {
                    const scale = containerRect.width / cssW;
                    this.canvas.style.width = (cssW * scale) + 'px';
                    this.canvas.style.height = (parseFloat(this.canvas.style.height) * scale) + 'px';
                }
            }

            drawMap() {
                // clear internal pixels
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // scale for dpr and zoom
                this.ctx.save();
                this.ctx.scale(this.dpr, this.dpr);
                this.ctx.scale(this.zoom, this.zoom);

                // coordinate origin: left-bottom (使用实际高度)
                this.ctx.translate(0, this.actualMapHeight);
                this.ctx.scale(1, -1);

                // apply offset (CSS px units converted by dividing by zoom)
                if (this.mapOffsetX !== undefined && this.mapOffsetY !== undefined) {
                    this.ctx.translate(this.mapOffsetX / this.zoom, this.mapOffsetY / this.zoom);
                }

                // draw cells
                for (const cell of this.cells) {
                    this.drawCell(cell, cell === this.selectedCell);
                }

                // draw axis
                this.drawCoordinateAxis();

                this.ctx.restore();
            }

            drawCell(cell, isSelected) {
                const { coordinates, id, row, col, layer } = cell;

                // polygon style
                this.ctx.strokeStyle = isSelected ? '#ff0000' : '#333';
                this.ctx.lineWidth = isSelected ? 2 : 1;

                // determine fill: selected -> red; highlighted layer -> green; otherwise checker
                if (isSelected) {
                    this.ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                } else if (this.highlightedLayers && this.highlightedLayers.has(layer)) {
                    this.ctx.fillStyle = 'rgba(0, 128, 0, 0.25)';
                } else {
                    this.ctx.fillStyle = ((row + col) % 2 === 0 ? '#f9f9f9' : '#ffffff');
                }

                // draw polygon (coordinates are in map units)
                this.ctx.beginPath();
                this.ctx.moveTo(coordinates[0][0], coordinates[0][1]);
                for (let i = 1; i < coordinates.length; i++) {
                    this.ctx.lineTo(coordinates[i][0], coordinates[i][1]);
                }
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();

                // === dynamic font sizing to avoid overflow ===
                // compute bounding box of the polygon
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                for (const p of coordinates) {
                    minX = Math.min(minX, p[0]);
                    maxX = Math.max(maxX, p[0]);
                    minY = Math.min(minY, p[1]);
                    maxY = Math.max(maxY, p[1]);
                }
                const boxWidth = maxX - minX;
                const boxHeight = maxY - minY;

                // padding inside the box (percentage of min dimension)
                const paddingRatio = 0.12;
                const padding = Math.max(1, Math.min(boxWidth, boxHeight) * paddingRatio);

                // choose an initial font size based on boxHeight (map units)
                const minFont = 6; // minimal readable font in map units
                const maxFont = Math.max(10, Math.floor(Math.min(boxWidth, boxHeight) * 0.6));
                let fontSize = Math.min(maxFont, Math.max(minFont, Math.round(boxHeight * 0.5)));

                // set text properties after flipping back to normal orientation for text measuring/drawing
                this.ctx.save();
                // flip so text draws upright (we are in a flipped coordinate system)
                this.ctx.scale(1, -1);

                const text = id.toString();
                const targetMaxWidth = Math.max(1, boxWidth - 2 * padding);

                // reduce font size until text width fits targetMaxWidth
                do {
                    this.ctx.font = `${fontSize}px Arial`;
                    const metrics = this.ctx.measureText(text);
                    const textWidth = metrics.width;
                    if (textWidth <= targetMaxWidth) break;
                    fontSize = Math.max(minFont, fontSize - 1);
                } while (fontSize > minFont);

                // final draw text centered
                this.ctx.fillStyle = isSelected ? '#ff0000' : '#666';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                this.ctx.fillText(text, centerX, -centerY);

                // 如果该格有资源或怪物，在格子中心下方显示简短标识 (显示已分配项数)
                if (cell.resources && cell.resources.length > 0) {
                    const resText = cell.resources.length > 1 ? `${cell.resources.length}A` : `${cell.resources[0].id}`;
                    // 使用较小字号显示
                    this.ctx.font = `${Math.max(8, Math.round(fontSize * 0.45))}px Arial`;
                    this.ctx.fillStyle = '#b00000';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'top';
                    // 在 id 的下方画
                    this.ctx.fillText(resText, centerX, -centerY + Math.max(8, fontSize * 0.6));
                }

                this.ctx.restore();
            }

            drawCoordinateAxis() {
                this.ctx.strokeStyle = '#000';
                this.ctx.lineWidth = 2;
                // X axis
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0);
                this.ctx.lineTo(this.actualMapWidth, 0);
                this.ctx.stroke();
                // Y axis
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0);
                this.ctx.lineTo(0, this.actualMapHeight);
                this.ctx.stroke();

                const fontSize = Math.max(10, Math.min(16, 14 * Math.sqrt(this.zoom)));
                this.ctx.save();
                this.ctx.scale(1, -1);
                this.ctx.fillStyle = '#000';
                this.ctx.font = `${fontSize}px Arial`;
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('0,0', 10, -10);
                this.ctx.fillText('X', this.actualMapWidth - 15, -10);
                this.ctx.fillText('Y', 10, -(this.actualMapHeight - 10));
                this.ctx.restore();
            }

            // helper: map event to map coordinates
            getEventMapCoordinates(event) {
                const rect = this.canvas.getBoundingClientRect();
                const screenX = event.clientX - rect.left;
                const screenY = event.clientY - rect.top;
                return this.screenToMapCoordinates(screenX, screenY, rect);
            }

            // convert CSS pixel coords (relative to canvas) to map coords
            screenToMapCoordinates(screenX, screenY, rect) {
                if (!rect) rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const internalX = screenX * scaleX;
                const internalY = screenY * scaleY;
                // internal -> user/map coords (internal units are css*dpr)
                let x = internalX / (this.dpr * this.zoom);
                let y = internalY / (this.dpr * this.zoom);
                // reverse applied offsets and flips
                x -= this.mapOffsetX / this.zoom;
                y -= this.mapOffsetY / this.zoom;
                // 使用实际高度进行反转
                y = this.actualMapHeight - y;
                if (this.mapAngle !== 0) {
                    const angleRad = -this.mapAngle * Math.PI / 180;
                    const cosA = Math.cos(angleRad);
                    const sinA = Math.sin(angleRad);
                    const rx = x * cosA - y * sinA;
                    const ry = x * sinA + y * cosA;
                    x = rx; y = ry;
                }
                return { x, y };
            }

            handleCanvasClick(event) {
                const { x, y } = this.getEventMapCoordinates(event);
                const clicked = this.cells.find(cell => this.isPointInPolygon(x, y, cell.coordinates));
                if (clicked) {
                    this.selectedCell = clicked;
                    this.updateCellInfo(clicked);
                    this.drawMap();
                }
            }

            handleCanvasHover(event) {
                const { x, y } = this.getEventMapCoordinates(event);
                const hovered = this.cells.find(cell => this.isPointInPolygon(x, y, cell.coordinates));
                this.canvas.style.cursor = hovered ? 'pointer' : 'crosshair';
            }

            isPointInPolygon(x, y, polygon) {
                let inside = false;
                const n = polygon.length;
                for (let i = 0, j = n - 1; i < n; j = i++) {
                    const xi = polygon[i][0], yi = polygon[i][1];
                    const xj = polygon[j][0], yj = polygon[j][1];
                    const intersect = ((yi > y) !== (yj > y)) && (x < (xi - xj) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }

            updateCellInfo(cell) {
				const { id, row, col, originalCoordinates, layer } = cell;
				const coordText = originalCoordinates.map((coord, index) => {
					const labels = ['左下角', '左上角', '右上角', '右下角'];
					const rounded = [Math.round(coord[0]), Math.round(coord[1])];
					return `${labels[index]}: (${rounded[0]}, ${rounded[1]})`;
				}).join('<br>');

				const layerDisplay = layer + 1;
				const angleInfo = this.mapAngle > 0 ? `<br><strong>倾斜角度:</strong> ${this.mapAngle}°` : '';

				// 资源显示 —— 显示为 "name: 数量"，每条单独一行，合并相同 id 的数量
				let resHtml = '';
				if (cell.resources && cell.resources.length > 0) {
					// 合并相同 id 的数量
					const counts = {};
					for (const r of cell.resources) {
						const idStr = String(r.id);
						const qty = (r.qty != null) ? Number(r.qty) : ((r.quantity != null) ? Number(r.quantity) : 1);
						counts[idStr] = (counts[idStr] || 0) + (isNaN(qty) ? 1 : qty);
					}

					const items = Object.entries(counts).map(([itemId, totalQty]) => {
						const found = (this.allItems || []).find(a => String(a.id) === String(itemId));
						const name = found ? found.name : itemId;
						return `${name}: ${totalQty}`;
					});

					resHtml = `<br><strong>已分配项:</strong><br>${items.join('<br>')}`;
				}

				document.getElementById('cellInfo').innerHTML = `
					<strong>格子 #${id}</strong><br>
					位置: 第${row + 1}行, 第${col + 1}列<br>
					圈层: 第${layerDisplay}圈${angleInfo}<br>
					<strong>坐标点:</strong><br>
					${coordText}
					${resHtml}
				`;
			}

            changeZoom(delta) {
                const newZoom = Math.max(0.1, Math.min(3, this.zoom + delta));
                if (newZoom !== this.zoom) {
                    this.zoom = newZoom;
                    this.updateCanvasSize();
                    this.drawMap();
                }
            }

            resetZoom() {
                if (this.zoom !== 1) {
                    this.zoom = 1;
                    this.updateCanvasSize();
                    this.drawMap();
                }
            }

            handleMouseDown(event) {
                if (event.button === 2) {
                    this.isDragging = true;
                    this.dragStartX = event.clientX;
                    this.dragStartY = event.clientY;
                    this.canvas.style.cursor = 'grabbing';
                    event.preventDefault();
                }
            }

            handleMouseMove(event) {
                if (this.isDragging) {
                    const deltaX = event.clientX - this.dragStartX;
                    const deltaY = event.clientY - this.dragStartY;
                    // mapOffset in CSS px
                    this.mapOffsetX += deltaX;
                    this.mapOffsetY -= deltaY;
                    this.dragStartX = event.clientX;
                    this.dragStartY = event.clientY;
                    this.drawMap();
                    event.preventDefault();
                } else {
                    this.handleCanvasHover(event);
                }
            }

            handleMouseUp(event) {
                if (this.isDragging) {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'crosshair';
                }
            }

            // 填充圈层选择框
            updateLayerSelect() {
                const select = document.getElementById('layerSelect');
                select.innerHTML = '';
                const layers = this.maxLayers || Math.ceil(Math.min(this.rows || 0, this.cols || 0) / 2);
                for (let i = 0; i < layers; i++) {
                    const opt = document.createElement('option');
                    opt.value = String(i); // 存储为零基索引
                    opt.text = `第 ${i + 1} 圈`;
                    select.appendChild(opt);
                }
            }

            updateLayerSelectSelection() {
                // no-op for now; kept for compatibility
            }

            applyLayerHighlight() {
                const sel = document.getElementById('layerSelect');
                const selected = Array.from(sel.selectedOptions).map(o => Number(o.value));
                this.highlightedLayers.clear();
                for (const s of selected) this.highlightedLayers.add(s);
                this.drawMap();
            }

            clearLayerHighlight() {
                this.highlightedLayers.clear();
                const sel = document.getElementById('layerSelect');
                for (const o of Array.from(sel.options)) o.selected = false;
                this.drawMap();
            }

            // 将选中的怪物/资源按各自的 qty 添加到被选圈层的格子上
            applyItemsToSelectedLayers(type) {
                // selected layers
                const layerSel = document.getElementById('layerSelect');
                const selectedLayers = Array.from(layerSel.selectedOptions).map(o => Number(o.value));
                if (selectedLayers.length === 0) {
                    alert('请先选择至少一个圈层。');
                    return;
                }

                const listSel = (type === 1) ? document.getElementById('monsterSelect') : document.getElementById('resourceSelect');
                const arr = (type === 1) ? this.monsters : this.resources;
                const selectedOpts = Array.from(listSel.selectedOptions || []);
                if (selectedOpts.length === 0) {
                    alert('请先在怪物/资源列表中选择要添加的项（可多选）。');
                    return;
                }

                // for each selected item, get qty from data or underlying array
                const itemsToApplyAll = selectedOpts.map(opt => {
                    const idStr = String(opt.value);
                    const found = arr.find(a => String(a.id) === idStr);
                    const qtyRaw = (found && found.qty != null) ? Number(found.qty) : (Number(opt.dataset.qty) || 0);
                    const qty = isNaN(qtyRaw) ? 0 : qtyRaw;
                    return { id: idStr, qty: qty };
                });

                // Filter out items with qty === 0 (do not add them)
                const itemsToApply = itemsToApplyAll.filter(it => Number(it.qty) > 0);
                const skippedZeroItems = itemsToApplyAll.length - itemsToApply.length;

                if (itemsToApply.length === 0) {
                    // All selected items have qty 0 -> prevent adding and inform user
                    alert('选中的项中所有数量均为 0，无法添加到圈层，请先将数量设为大于 0。');
                    return;
                }

                // find all cells in selected layers
                const targetCells = this.cells.filter(c => selectedLayers.includes(c.layer));
                if (targetCells.length === 0) {
                    alert('选中的圈层没有任何格子。');
                    return;
                }

                // Add only items with qty > 0
                for (const cell of targetCells) {
                    for (const it of itemsToApply) {
                        cell.resources.push({ type, id: it.id, qty: it.qty });
                    }
                }

                this.drawMap();

                // Provide informative alert: success + info about skipped zero-qty items
                let msg = `添加完成：共 ${itemsToApply.length} 项已添加到 ${targetCells.length} 个格子（每项数量>0）。`;
                if (skippedZeroItems > 0) {
                    msg += `\n有 ${skippedZeroItems} 项因数量为 0 被跳过，未添加。`;
                }
                alert(msg);
            }

            exportSeparatedData() {
                // export monsters first then empty line then resources
                const monsters = [];
                const resources = [];
                for (const c of this.cells) {
                    if (!c.resources || c.resources.length === 0) continue;
                    for (const r of c.resources) {
                        if (r.type === 1) {
                            monsters.push({ cellId: c.id, id: r.id, qty: r.qty });
                        } else if (r.type === 2) {
                            resources.push({ cellId: c.id, id: r.id, qty: r.qty });
                        }
                    }
                }
                const lines = [];
                for (const m of monsters) lines.push(`cell:${m.cellId}, id:${m.id}, qty:${m.qty}`);
                lines.push('');
                for (const r of resources) lines.push(`cell:${r.cellId}, id:${r.id}, qty:${r.qty}`);

                const blob = new Blob([lines.join('\n')], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'export.txt';
                a.click();
                URL.revokeObjectURL(url);
            }

            printData() {
                console.log('cells:', this.cells);
                alert('已在控制台输出当前格子数据（包含分配项）。');
            }
        }

        // instantiate
        window.addEventListener('DOMContentLoaded', () => {
            window.mapTools = new MapTools();
        });
    </script>
	<script src="layout-toggle.js"></script>
</body>
</html>