<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>地图格子生成工具</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            display: flex;
            gap: 20px;
            max-width: 1400px;
            width: 100%;
            flex-wrap: wrap;
            align-items: flex-start;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            width: 320px;
            max-width: 100%;
            flex-shrink: 0;
            flex-basis: 320px;
        }

        .controls h1 {
            font-size: 20px;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }

        .input-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .input-hint {
            display: block;
            margin-top: 3px;
            font-size: 11px;
            color: #888;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        #generateBtn {
            background-color: #007bff;
            color: white;
            grid-column: span 2;
        }

        #generateBtn:hover {
            background-color: #0056b3;
        }

        #zoomInBtn, #zoomOutBtn {
            background-color: #28a745;
            color: white;
        }

        #zoomInBtn:hover, #zoomOutBtn:hover {
            background-color: #1e7e34;
        }

        #printBtn {
            background-color: #dc3545;
            color: white;
            grid-column: span 2;
        }

        #printBtn:hover {
            background-color: #c82333;
        }

        .info-panel {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }

        .info-panel h3 {
            margin-bottom: 10px;
            color: #333;
        }

        #cellInfo {
            font-size: 14px;
            color: #666;
            line-height: 1.5;
        }

        .preset-btn {
            padding: 5px 8px;
            font-size: 12px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            color: #495057;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
        }

        .preset-btn.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }

        .canvas-container {
            flex: 1 1 600px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* 默认不出现滚动条 */
            min-width: 0;
        }

        #mapCanvas {
            border: 1px solid #ccc;
            cursor: crosshair;
            display: block;
            max-width: 100%;
            height: auto;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .controls {
                width: 100%;
            }

            .canvas-container {
                min-height: 400px;
            }
        }

        @media (max-width: 480px) {
            .button-group {
                grid-template-columns: 1fr;
            }

            #generateBtn, #printBtn {
                grid-column: span 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <h1>地图格子生成工具</h1>
            <div class="input-group">
                <label for="mapWidth">地图宽度 (像素):</label>
                <input type="number" id="mapWidth" value="1199" min="100" max="2000">
                <small class="input-hint">范围: 100-2000像素</small>
            </div>
            <div class="input-group">
                <label for="mapHeight">地图高度 (像素):</label>
                <input type="number" id="mapHeight" value="1199" min="100" max="2000">
                <small class="input-hint">范围: 100-2000像素</small>
            </div>
            <div class="input-group">
                <label for="cellSize">格子边长 (像素):</label>
                <input type="number" id="cellSize" value="100" min="10" max="200">
                <small class="input-hint">范围: 10-200像素</small>
            </div>
            <div class="button-group">
                <button id="generateBtn">生成地图</button>
                <button id="zoomInBtn">放大</button>
                <button id="zoomOutBtn">缩小</button>
                <button id="printBtn">打印数据</button>
            </div>
            <div class="info-panel">
                <h3>格子信息</h3>
                <p id="cellInfo">点击格子查看详细信息</p>
            </div>
        </div>
        <div class="canvas-container">
            <canvas id="mapCanvas"></canvas>
        </div>
    </div>
    <script>
        class MapTools {
            constructor() {
                this.canvas = document.getElementById('mapCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvasContainer = document.querySelector('.canvas-container');
                this.cells = [];
                this.selectedCell = null;
                this.zoom = 1;
                this.mapWidth = 800;
                this.mapHeight = 600;
                this.cellSize = 100;
                this.mapAngle = 0; // 0 or 45

                // devicePixelRatio 支持
                this.dpr = window.devicePixelRatio || 1;

                // 拖拽相关
                this.isDragging = false;
                this.dragStartX = 0;
                this.dragStartY = 0;
                this.mapOffsetX = 0; // CSS 像素
                this.mapOffsetY = 0;

                this.initEventListeners();
                this.generateMap();
            }

            initEventListeners() {
                document.getElementById('generateBtn').addEventListener('click', () => {
                    this.generateMap();
                });

                document.getElementById('zoomInBtn').addEventListener('click', () => {
                    this.changeZoom(0.1);
                });

                document.getElementById('zoomOutBtn').addEventListener('click', () => {
                    this.changeZoom(-0.1);
                });

                document.getElementById('printBtn').addEventListener('click', () => {
                    this.printData();
                });

                // preset buttons if exist
                document.querySelectorAll('.preset-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const angle = parseInt(e.target.dataset.angle);
                        this.mapAngle = angle;
                        this.updatePresetButtons();
                        this.updateCanvasSize();
                        this.drawMap();
                    });
                });

                // unified event to map coordinate
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleCanvasHover(e));

                // dragging
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('mouseleave', (e) => this.handleMouseUp(e));

                // resize / dpr change
                window.addEventListener('resize', () => {
                    this.dpr = window.devicePixelRatio || 1;
                    this.updateCanvasSize();
                    this.drawMap();
                });
            }

            updatePresetButtons() {
                document.querySelectorAll('.preset-btn').forEach(btn => {
                    const angle = parseInt(btn.dataset.angle);
                    if (angle === this.mapAngle) btn.classList.add('active'); else btn.classList.remove('active');
                });
            }

            generateMap() {
                // read inputs
                this.mapWidth = parseInt(document.getElementById('mapWidth').value) || this.mapWidth;
                this.mapHeight = parseInt(document.getElementById('mapHeight').value) || this.mapHeight;
                this.cellSize = parseInt(document.getElementById('cellSize').value) || this.cellSize;

                // validate
                if (this.mapWidth < 100 || this.mapWidth > 2000 ||
                    this.mapHeight < 100 || this.mapHeight > 2000 ||
                    this.cellSize < 10 || this.cellSize > 200) {
                    alert('请输入有效的参数范围：\n地图边长: 100-2000像素\n格子边长: 10-200像素');
                    return;
                }

                if (this.mapAngle !== 0 && this.mapAngle !== 45) {
                    alert('请选择有效的角度：0° 或 45°');
                    return;
                }

                this.cols = Math.ceil(this.mapWidth / this.cellSize);
                this.rows = Math.ceil(this.mapHeight / this.cellSize);

                this.generateCellsSpiral();

                // Fit by available viewport height so map shows fully without vertical scroll
                const viewportHeight = window.innerHeight;
                const containerRect = this.canvasContainer.getBoundingClientRect();
                // available height below the top of the canvas container (leave small margin)
                const availableHeight = Math.max(100, viewportHeight - containerRect.top - 20);

                // fitZoom based on mapHeight
                const fitZoom = availableHeight / this.mapHeight;
                this.zoom = Math.min(1, fitZoom);

                this.updateCanvasSize();
                this.drawMap();
                this.updatePresetButtons();
            }

            generateCellsSpiral() {
                this.cells = [];
                let cellId = 1;
                const layers = Math.ceil(Math.min(this.rows, this.cols) / 2);

                for (let layer = 0; layer < layers; layer++) {
                    const topRow = this.rows - 1 - layer;
                    const bottomRow = layer;
                    const leftCol = layer;
                    const rightCol = this.cols - 1 - layer;

                    for (let col = leftCol; col <= rightCol; col++) this.addCell(bottomRow, col, cellId++);
                    for (let row = bottomRow + 1; row <= topRow; row++) this.addCell(row, rightCol, cellId++);
                    for (let col = rightCol - 1; col >= leftCol; col--) this.addCell(topRow, col, cellId++);
                    for (let row = topRow - 1; row > bottomRow; row--) this.addCell(row, leftCol, cellId++);
                }
            }

            addCell(row, col, id) {
                const cellSizeMinusOne = this.cellSize - 1;
                const originalCoordinates = [
                    [col * this.cellSize, row * this.cellSize],
                    [col * this.cellSize, row * this.cellSize + cellSizeMinusOne],
                    [col * this.cellSize + cellSizeMinusOne, row * this.cellSize + cellSizeMinusOne],
                    [col * this.cellSize + cellSizeMinusOne, row * this.cellSize]
                ];

                if (this.mapAngle === 0) {
                    this.cells.push({
                        id, row, col,
                        x: col * this.cellSize,
                        y: row * this.cellSize,
                        coordinates: originalCoordinates,
                        originalCoordinates
                    });
                    return;
                }

                const angleRad = this.mapAngle * Math.PI / 180;
                const cosAngle = Math.cos(angleRad);
                const sinAngle = Math.sin(angleRad);

                const coordinates = originalCoordinates.map(([x, y]) => {
                    const tx = x * cosAngle - y * sinAngle;
                    const ty = x * sinAngle + y * cosAngle;
                    return [tx, ty];
                });

                this.cells.push({
                    id, row, col,
                    x: col * this.cellSize,
                    y: row * this.cellSize,
                    coordinates,
                    originalCoordinates
                });
            }

            updateCanvasSize() {
                if (this.mapAngle === 0) {
                    const cssWidth = this.mapWidth * this.zoom;
                    const cssHeight = this.mapHeight * this.zoom;
                    this.canvas.width = Math.round(cssWidth * this.dpr);
                    this.canvas.height = Math.round(cssHeight * this.dpr);
                    this.canvas.style.width = cssWidth + 'px';
                    this.canvas.style.height = cssHeight + 'px';
                    this.mapOffsetX = 0;
                    this.mapOffsetY = 0;
                } else {
                    const angleRad = -this.mapAngle * Math.PI / 180;
                    const cosAngle = Math.cos(angleRad);
                    const sinAngle = Math.sin(angleRad);

                    const corners = [
                        [0, 0],
                        [0, this.mapHeight],
                        [this.mapWidth, this.mapHeight],
                        [this.mapWidth, 0]
                    ];

                    const transformed = corners.map(([x, y]) => {
                        return [x * cosAngle - y * sinAngle, x * sinAngle + y * cosAngle];
                    });

                    const minX = Math.min(...transformed.map(c => c[0]));
                    const maxX = Math.max(...transformed.map(c => c[0]));
                    const minY = Math.min(...transformed.map(c => c[1]));
                    const maxY = Math.max(...transformed.map(c => c[1]));

                    const padding = 20;
                    const cssWidth = (maxX - minX + padding * 2) * this.zoom;
                    const cssHeight = (maxY - minY + padding * 2) * this.zoom;

                    this.canvas.width = Math.round(cssWidth * this.dpr);
                    this.canvas.height = Math.round(cssHeight * this.dpr);
                    this.canvas.style.width = cssWidth + 'px';
                    this.canvas.style.height = cssHeight + 'px';

                    this.mapOffsetX = (-minX + padding) * this.zoom;
                    this.mapOffsetY = (-minY + padding) * this.zoom;
                }

                // If canvas CSS width exceeds container, scale CSS down to fit (not internal pixels)
                const containerRect = this.canvasContainer.getBoundingClientRect();
                const cssW = parseFloat(this.canvas.style.width) || (this.canvas.width / this.dpr);
                if (cssW > containerRect.width) {
                    const scale = containerRect.width / cssW;
                    this.canvas.style.width = (cssW * scale) + 'px';
                    this.canvas.style.height = (parseFloat(this.canvas.style.height) * scale) + 'px';
                }
            }

            drawMap() {
                // clear internal pixels
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // scale for dpr and zoom
                this.ctx.save();
                this.ctx.scale(this.dpr, this.dpr);
                this.ctx.scale(this.zoom, this.zoom);

                // coordinate origin: left-bottom
                this.ctx.translate(0, this.mapHeight);
                this.ctx.scale(1, -1);

                // apply offset (CSS px units converted by dividing by zoom)
                if (this.mapOffsetX !== undefined && this.mapOffsetY !== undefined) {
                    this.ctx.translate(this.mapOffsetX / this.zoom, this.mapOffsetY / this.zoom);
                }

                // draw cells
                for (const cell of this.cells) {
                    this.drawCell(cell, cell === this.selectedCell);
                }

                // draw axis
                this.drawCoordinateAxis();

                this.ctx.restore();
            }

            drawCell(cell, isSelected) {
                const { coordinates, id, row, col } = cell;

                // polygon style
                this.ctx.strokeStyle = isSelected ? '#ff0000' : '#333';
                this.ctx.lineWidth = isSelected ? 2 : 1;
                this.ctx.fillStyle = isSelected ? 'rgba(255, 0, 0, 0.2)' : ((row + col) % 2 === 0 ? '#f9f9f9' : '#ffffff');

                // draw polygon (coordinates are in map units)
                this.ctx.beginPath();
                this.ctx.moveTo(coordinates[0][0], coordinates[0][1]);
                for (let i = 1; i < coordinates.length; i++) {
                    this.ctx.lineTo(coordinates[i][0], coordinates[i][1]);
                }
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();

                // === dynamic font sizing to avoid overflow ===
                // compute bounding box of the polygon
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                for (const p of coordinates) {
                    minX = Math.min(minX, p[0]);
                    maxX = Math.max(maxX, p[0]);
                    minY = Math.min(minY, p[1]);
                    maxY = Math.max(maxY, p[1]);
                }
                const boxWidth = maxX - minX;
                const boxHeight = maxY - minY;

                // padding inside the box (percentage of min dimension)
                const paddingRatio = 0.12;
                const padding = Math.max(1, Math.min(boxWidth, boxHeight) * paddingRatio);

                // choose an initial font size based on boxHeight (map units)
                const minFont = 6; // minimal readable font in map units
                const maxFont = Math.max(10, Math.floor(Math.min(boxWidth, boxHeight) * 0.6));
                let fontSize = Math.min(maxFont, Math.max(minFont, Math.round(boxHeight * 0.5)));

                // set text properties after flipping back to normal orientation for text measuring/drawing
                this.ctx.save();
                // flip so text draws upright (we are in a flipped coordinate system)
                this.ctx.scale(1, -1);

                const text = id.toString();
                const targetMaxWidth = Math.max(1, boxWidth - 2 * padding);

                // reduce font size until text width fits targetMaxWidth
                do {
                    this.ctx.font = `${fontSize}px Arial`;
                    const metrics = this.ctx.measureText(text);
                    const textWidth = metrics.width;
                    if (textWidth <= targetMaxWidth) break;
                    fontSize = Math.max(minFont, fontSize - 1);
                } while (fontSize > minFont);

                // final draw text centered
                this.ctx.fillStyle = isSelected ? '#ff0000' : '#666';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                this.ctx.fillText(text, centerX, -centerY);

                this.ctx.restore();
            }

            drawCoordinateAxis() {
                this.ctx.strokeStyle = '#000';
                this.ctx.lineWidth = 2;
                // X axis
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0);
                this.ctx.lineTo(this.mapWidth, 0);
                this.ctx.stroke();
                // Y axis
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0);
                this.ctx.lineTo(0, this.mapHeight);
                this.ctx.stroke();

                const fontSize = Math.max(10, Math.min(16, 14 * Math.sqrt(this.zoom)));
                this.ctx.save();
                this.ctx.scale(1, -1);
                this.ctx.fillStyle = '#000';
                this.ctx.font = `${fontSize}px Arial`;
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('0,0', 10, -10);
                this.ctx.fillText('X', this.mapWidth - 15, -10);
                this.ctx.fillText('Y', 10, -(this.mapHeight - 10));
                this.ctx.restore();
            }

            // helper: map event to map coordinates
            getEventMapCoordinates(event) {
                const rect = this.canvas.getBoundingClientRect();
                const screenX = event.clientX - rect.left;
                const screenY = event.clientY - rect.top;
                return this.screenToMapCoordinates(screenX, screenY, rect);
            }

            // convert CSS pixel coords (relative to canvas) to map coords
            screenToMapCoordinates(screenX, screenY, rect) {
                if (!rect) rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const internalX = screenX * scaleX;
                const internalY = screenY * scaleY;
                // internal -> user/map coords (internal units are css*dpr)
                let x = internalX / (this.dpr * this.zoom);
                let y = internalY / (this.dpr * this.zoom);
                // reverse applied offsets and flips
                x -= this.mapOffsetX / this.zoom;
                y -= this.mapOffsetY / this.zoom;
                y = this.mapHeight - y;
                if (this.mapAngle !== 0) {
                    const angleRad = -this.mapAngle * Math.PI / 180;
                    const cosA = Math.cos(angleRad);
                    const sinA = Math.sin(angleRad);
                    const rx = x * cosA - y * sinA;
                    const ry = x * sinA + y * cosA;
                    x = rx; y = ry;
                }
                return { x, y };
            }

            handleCanvasClick(event) {
                const { x, y } = this.getEventMapCoordinates(event);
                const clicked = this.cells.find(cell => this.isPointInPolygon(x, y, cell.coordinates));
                if (clicked) {
                    this.selectedCell = clicked;
                    this.updateCellInfo(clicked);
                    this.drawMap();
                }
            }

            handleCanvasHover(event) {
                const { x, y } = this.getEventMapCoordinates(event);
                const hovered = this.cells.find(cell => this.isPointInPolygon(x, y, cell.coordinates));
                this.canvas.style.cursor = hovered ? 'pointer' : 'crosshair';
            }

            isPointInPolygon(x, y, polygon) {
                let inside = false;
                const n = polygon.length;
                for (let i = 0, j = n - 1; i < n; j = i++) {
                    const xi = polygon[i][0], yi = polygon[i][1];
                    const xj = polygon[j][0], yj = polygon[j][1];
                    const intersect = ((yi > y) !== (yj > y)) && (x < (xi - xj) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }

            updateCellInfo(cell) {
                const { id, row, col, originalCoordinates } = cell;
                const coordText = originalCoordinates.map((coord, index) => {
                    const labels = ['左下角', '左上角', '右上角', '右下角'];
                    const rounded = [Math.round(coord[0]), Math.round(coord[1])];
                    return `${labels[index]}: (${rounded[0]}, ${rounded[1]})`;
                }).join('<br>');

                const layer = Math.min(row, col, this.rows - 1 - row, this.cols - 1 - col);
                const angleInfo = this.mapAngle > 0 ? `<br><strong>倾斜角度:</strong> ${this.mapAngle}°` : '';

                document.getElementById('cellInfo').innerHTML = `
                    <strong>格子 #${id}</strong><br>
                    位置: 第${row + 1}行, 第${col + 1}列<br>
                    圈层: 第${layer + 1}圈${angleInfo}<br>
                    <strong>坐标点:</strong><br>
                    ${coordText}
                `;
            }

            changeZoom(delta) {
                const newZoom = Math.max(0.1, Math.min(3, this.zoom + delta));
                if (newZoom !== this.zoom) {
                    this.zoom = newZoom;
                    this.updateCanvasSize();
                    this.drawMap();
                }
            }

            resetZoom() {
                if (this.zoom !== 1) {
                    this.zoom = 1;
                    this.updateCanvasSize();
                    this.drawMap();
                }
            }

            handleMouseDown(event) {
                if (event.button === 2) {
                    this.isDragging = true;
                    this.dragStartX = event.clientX;
                    this.dragStartY = event.clientY;
                    this.canvas.style.cursor = 'grabbing';
                    event.preventDefault();
                }
            }

            handleMouseMove(event) {
                if (this.isDragging) {
                    const deltaX = event.clientX - this.dragStartX;
                    const deltaY = event.clientY - this.dragStartY;
                    // mapOffset in CSS px
                    this.mapOffsetX += deltaX;
                    this.mapOffsetY -= deltaY;
                    this.dragStartX = event.clientX;
                    this.dragStartY = event.clientY;
                    this.drawMap();
                    event.preventDefault();
                } else {
                    this.handleCanvasHover(event);
                }
            }

            handleMouseUp(event) {
                if (this.isDragging) {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'crosshair';
                }
            }

            printData() {
                if (this.cells.length === 0) {
                    alert('请先生成地图！');
                    return;
                }
                let content = '';
                this.cells.forEach(cell => {
                    const coords = cell.originalCoordinates.map(c => `${Math.round(c[0])};${Math.round(c[1])}`).join('|');
                    content += `${cell.id}:${coords}\n`;
                });
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `map_data_angle${this.mapAngle}_${Date.now()}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new MapTools();
        });
    </script>
</body>
</html>